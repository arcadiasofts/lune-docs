---
title: 'ìƒëª…ì£¼ê¸° ê´€ë¦¬'
path: 'orbital/application/lifecycle'
product: 'Orbital'
category: 'Application'
lastUpdate: 2025-09-05
order: 15
---

## ê°œìš”

Orbital ì• í”Œë¦¬ì¼€ì´ì…˜ì˜ ìƒëª…ì£¼ê¸°ë¥¼ íš¨ê³¼ì ìœ¼ë¡œ ê´€ë¦¬í•˜ì—¬ ì•ˆì •ì ì¸ ì„œë²„ ìš´ì˜ì„ ë³´ì¥í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ì„œë²„ ì‹œì‘, ì¤‘ì§€, ì¬ì‹œì‘ ë“±ì˜ ì‘ì—…ì„ ì•ˆì „í•˜ê²Œ ì²˜ë¦¬í•˜ëŠ” ë°©ë²•ì„ ë‹¤ë£¹ë‹ˆë‹¤.

## ì„œë²„ ì‹œì‘

### ê¸°ë³¸ ì„œë²„ ì‹œì‘

```rust
use orbital::application::OrbitApplication;

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    let mut app = OrbitApplication::new(
        Some("Lifecycle Server".to_string()),
        None,
        None
    );

    // ë¼ìš°í„° ë“±ë¡ ë“±...

    println!("ğŸš€ ì„œë²„ ì‹œì‘ ì¤‘...");

    // ë¸”ë¡œí‚¹ ë°©ì‹ìœ¼ë¡œ ì„œë²„ ì‹œì‘
    app.listen(8080).await?;

    Ok(())
}
```

### ë¹„ë™ê¸° ì„œë²„ ì‹œì‘

```rust
use orbital::application::OrbitApplication;

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    let mut app = OrbitApplication::new(
        Some("Async Server".to_string()),
        None,
        None
    );

    // ì„œë²„ë¥¼ ë°±ê·¸ë¼ìš´ë“œì—ì„œ ì‹œì‘
    let server_handle = tokio::spawn(async move {
        if let Err(e) = app.listen(8080).await {
            eprintln!("ì„œë²„ ì˜¤ë¥˜: {}", e);
        }
    });

    // ë‹¤ë¥¸ ì‘ì—… ìˆ˜í–‰ ê°€ëŠ¥
    println!("ì„œë²„ê°€ ë°±ê·¸ë¼ìš´ë“œì—ì„œ ì‹¤í–‰ ì¤‘ì…ë‹ˆë‹¤...");

    // í•„ìš”ì‹œ ì„œë²„ ì™„ë£Œ ëŒ€ê¸°
    server_handle.await?;

    Ok(())
}
```

## Graceful Shutdown

### ì‹ í˜¸ ê¸°ë°˜ ì¢…ë£Œ

```rust
use tokio::signal;
use orbital::application::OrbitApplication;

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    let mut app = OrbitApplication::new(
        Some("Graceful Server".to_string()),
        None,
        None
    );

    // ë¼ìš°í„° ë“±ë¡ ë“±...

    println!("ğŸš€ ì„œë²„ ì‹œì‘ ì¤‘...");

    // ì„œë²„ ì‹œì‘ê³¼ ì¢…ë£Œ ì‹ í˜¸ ëŒ€ê¸°ë¥¼ ë™ì‹œì—
    tokio::select! {
        result = app.listen(8080) => {
            if let Err(e) = result {
                eprintln!("ì„œë²„ ì˜¤ë¥˜: {}", e);
            }
        }
        _ = signal::ctrl_c() => {
            println!("\nğŸ›‘ ì¢…ë£Œ ì‹ í˜¸ ìˆ˜ì‹ , ì„œë²„ë¥¼ ì•ˆì „í•˜ê²Œ ì¢…ë£Œí•©ë‹ˆë‹¤...");

            // ì• í”Œë¦¬ì¼€ì´ì…˜ ì¤‘ì§€
            let closed_connections = app.stop().await;
            println!("âœ… {} ê°œì˜ ì—°ê²°ì´ ì•ˆì „í•˜ê²Œ ì¢…ë£Œë˜ì—ˆìŠµë‹ˆë‹¤", closed_connections);
        }
    }

    Ok(())
}
```

### ë‹¤ì¤‘ ì‹ í˜¸ ì²˜ë¦¬

```rust
use tokio::signal::unix::{signal, SignalKind};
use orbital::application::OrbitApplication;

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    let mut app = OrbitApplication::new(
        Some("Multi-Signal Server".to_string()),
        None,
        None
    );

    // ë‹¤ì–‘í•œ ì‹ í˜¸ í•¸ë“¤ëŸ¬ ì„¤ì •
    let mut sigterm = signal(SignalKind::terminate())?;
    let mut sigint = signal(SignalKind::interrupt())?;
    let mut sigusr1 = signal(SignalKind::user_defined1())?;

    println!("ğŸš€ ì„œë²„ ì‹œì‘ ì¤‘...");

    tokio::select! {
        result = app.listen(8080) => {
            if let Err(e) = result {
                eprintln!("ì„œë²„ ì˜¤ë¥˜: {}", e);
            }
        }
        _ = sigterm.recv() => {
            println!("ğŸ“‹ SIGTERM ì‹ í˜¸ ìˆ˜ì‹  - ì •ìƒ ì¢…ë£Œ");
            let closed_connections = app.stop().await;
            println!("âœ… {} ê°œì˜ ì—°ê²°ì´ ì•ˆì „í•˜ê²Œ ì¢…ë£Œë˜ì—ˆìŠµë‹ˆë‹¤", closed_connections);
        }
        _ = sigint.recv() => {
            println!("âš¡ SIGINT ì‹ í˜¸ ìˆ˜ì‹  - ì¦‰ì‹œ ì¢…ë£Œ");
            let closed_connections = app.stop().await;
            println!("âœ… {} ê°œì˜ ì—°ê²°ì´ ì•ˆì „í•˜ê²Œ ì¢…ë£Œë˜ì—ˆìŠµë‹ˆë‹¤", closed_connections);
        }
        _ = sigusr1.recv() => {
            println!("ğŸ”„ SIGUSR1 ì‹ í˜¸ ìˆ˜ì‹  - ì„¤ì • ì¬ë¡œë“œ");
            // ì„¤ì • ì¬ë¡œë“œ ë¡œì§
            reload_configuration(&mut app).await;
        }
    }

    Ok(())
}

async fn reload_configuration(app: &mut OrbitApplication) {
    println!("âš™ï¸ ì„¤ì •ì„ ì¬ë¡œë“œí•˜ëŠ” ì¤‘...");

    // ì‹¤ì œë¡œëŠ” ì„¤ì • íŒŒì¼ì„ ë‹¤ì‹œ ì½ê³  ì ìš©
    tokio::time::sleep(tokio::time::Duration::from_secs(1)).await;

    println!("âœ… ì„¤ì • ì¬ë¡œë“œ ì™„ë£Œ");
}
```

## ì„œë²„ ì¬ì‹œì‘

### ì• í”Œë¦¬ì¼€ì´ì…˜ ì¬ì‹œì‘

```rust
use orbital::application::OrbitApplication;

async fn restart_application(mut app: OrbitApplication) -> Result<(), Box<dyn std::error::Error>> {
    println!("ğŸ”„ ì• í”Œë¦¬ì¼€ì´ì…˜ ì¬ì‹œì‘ ì¤‘...");

    // í˜„ì¬ ì‹¤í–‰ ì¤‘ì¸ ì„œë²„ ì¤‘ì§€
    if app.is_running() {
        let closed_connections = app.stop().await;
        println!("ê¸°ì¡´ ì—°ê²° {} ê°œ ì¢…ë£Œ", closed_connections);
    }

    // ì ì‹œ ëŒ€ê¸° (ì—°ê²° ì •ë¦¬ ì‹œê°„)
    tokio::time::sleep(tokio::time::Duration::from_secs(2)).await;

    // ì„œë²„ ì¬ì‹œì‘
    println!("ğŸš€ ì„œë²„ ì¬ì‹œì‘...");
    app.listen(8080).await?;

    Ok(())
}

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    let app = OrbitApplication::new(
        Some("Restartable Server".to_string()),
        None,
        None
    );

    // ì¬ì‹œì‘ ë¡œì§ ì‹¤í–‰
    restart_application(app).await?;

    Ok(())
}
```

### ë¬´ì¤‘ë‹¨ ì¬ì‹œì‘ (Zero-Downtime Restart)

```rust
use orbital::application::OrbitApplication;
use std::sync::Arc;
use tokio::sync::Mutex;

struct ServerManager {
    current_app: Arc<Mutex<Option<OrbitApplication>>>,
}

impl ServerManager {
    fn new() -> Self {
        Self {
            current_app: Arc::new(Mutex::new(None)),
        }
    }

    async fn start_server(&self, port: u16) -> Result<(), Box<dyn std::error::Error>> {
        let app = OrbitApplication::new(
            Some("Zero-Downtime Server".to_string()),
            None,
            None
        );

        // ìƒˆ ì„œë²„ ì‹œì‘
        let app_clone = app.clone();
        let server_handle = tokio::spawn(async move {
            if let Err(e) = app_clone.listen(port).await {
                eprintln!("ì„œë²„ ì˜¤ë¥˜: {}", e);
            }
        });

        // í˜„ì¬ ì•± ì—…ë°ì´íŠ¸
        {
            let mut current = self.current_app.lock().await;
            *current = Some(app);
        }

        println!("âœ… ìƒˆ ì„œë²„ê°€ í¬íŠ¸ {}ì—ì„œ ì‹œì‘ë˜ì—ˆìŠµë‹ˆë‹¤", port);

        // ì„œë²„ ì™„ë£Œ ëŒ€ê¸°
        server_handle.await?;

        Ok(())
    }

    async fn restart_server(&self, new_port: u16) -> Result<(), Box<dyn std::error::Error>> {
        println!("ğŸ”„ ë¬´ì¤‘ë‹¨ ì¬ì‹œì‘ ì‹œì‘...");

        // 1. ìƒˆ í¬íŠ¸ì—ì„œ ìƒˆ ì„œë²„ ì‹œì‘
        let new_app = OrbitApplication::new(
            Some("New Server Instance".to_string()),
            None,
            None
        );

        let new_app_clone = new_app.clone();
        let new_server_handle = tokio::spawn(async move {
            if let Err(e) = new_app_clone.listen(new_port).await {
                eprintln!("ìƒˆ ì„œë²„ ì˜¤ë¥˜: {}", e);
            }
        });

        // ìƒˆ ì„œë²„ê°€ ì¤€ë¹„ë  ë•Œê¹Œì§€ ì ì‹œ ëŒ€ê¸°
        tokio::time::sleep(tokio::time::Duration::from_secs(2)).await;

        // 2. ê¸°ì¡´ ì„œë²„ ì¤‘ì§€
        {
            let mut current = self.current_app.lock().await;
            if let Some(old_app) = current.take() {
                let closed_connections = old_app.stop().await;
                println!("ğŸ›‘ ê¸°ì¡´ ì„œë²„ ì¤‘ì§€ ({} ì—°ê²° ì¢…ë£Œ)", closed_connections);
            }
        }

        // 3. ìƒˆ ì„œë²„ë¥¼ í˜„ì¬ ì„œë²„ë¡œ ì„¤ì •
        {
            let mut current = self.current_app.lock().await;
            *current = Some(new_app);
        }

        println!("âœ… ë¬´ì¤‘ë‹¨ ì¬ì‹œì‘ ì™„ë£Œ (ìƒˆ í¬íŠ¸: {})", new_port);

        // ìƒˆ ì„œë²„ ì™„ë£Œ ëŒ€ê¸°
        new_server_handle.await?;

        Ok(())
    }
}

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    let server_manager = ServerManager::new();

    // ì´ˆê¸° ì„œë²„ ì‹œì‘
    server_manager.start_server(8080).await?;

    Ok(())
}
```

## í—¬ìŠ¤ ì²´í¬

### ì„œë²„ ìƒíƒœ í™•ì¸

```rust
use orbital::application::OrbitApplication;
use orbital::router::{Router, RouteResponse};
use serde_json::json;
use std::sync::Arc;

async fn setup_health_check_routes(app: &mut OrbitApplication) -> Result<(), Box<dyn std::error::Error>> {
    let mut health_router = Router::new("Health Check Router");

    // ê¸°ë³¸ í—¬ìŠ¤ ì²´í¬
    health_router.read("/health", Arc::new(|_ctx| {
        Ok(RouteResponse::json(json!({
            "status": "healthy",
            "timestamp": chrono::Utc::now().to_rfc3339(),
            "service": "orbital-server"
        })))
    }));

    // ìƒì„¸ í—¬ìŠ¤ ì²´í¬
    health_router.read("/health/detailed", Arc::new(|ctx| {
        // ì‹¤ì œë¡œëŠ” ctxë¥¼ í†µí•´ ì•± ìƒíƒœì— ì ‘ê·¼
        Ok(RouteResponse::json(json!({
            "status": "healthy",
            "timestamp": chrono::Utc::now().to_rfc3339(),
            "details": {
                "database": "connected",
                "memory_usage_mb": 256,
                "cpu_usage_percent": 15.5,
                "active_connections": 42,
                "uptime_seconds": 3600
            }
        })))
    }));

    // ì¤€ë¹„ ìƒíƒœ ì²´í¬ (Readiness Probe)
    health_router.read("/ready", Arc::new(|_ctx| {
        // ì„œë²„ê°€ ìš”ì²­ì„ ë°›ì„ ì¤€ë¹„ê°€ ë˜ì—ˆëŠ”ì§€ í™•ì¸
        let is_ready = true; // ì‹¤ì œë¡œëŠ” ì´ˆê¸°í™” ìƒíƒœ í™•ì¸

        if is_ready {
            Ok(RouteResponse::json(json!({
                "status": "ready",
                "timestamp": chrono::Utc::now().to_rfc3339()
            })))
        } else {
            Ok(RouteResponse::error(503, "Service not ready"))
        }
    }));

    // ìƒì¡´ í™•ì¸ (Liveness Probe)
    health_router.read("/live", Arc::new(|_ctx| {
        Ok(RouteResponse::json(json!({
            "status": "alive",
            "timestamp": chrono::Utc::now().to_rfc3339()
        })))
    }));

    app.register(health_router)?;
    Ok(())
}

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    let mut app = OrbitApplication::new(
        Some("Health Check Server".to_string()),
        None,
        None
    );

    // í—¬ìŠ¤ ì²´í¬ ë¼ìš°íŠ¸ ì„¤ì •
    setup_health_check_routes(&mut app).await?;

    println!("ğŸš€ í—¬ìŠ¤ ì²´í¬ê°€ í™œì„±í™”ëœ ì„œë²„ ì‹œì‘");
    println!("ğŸ“¡ í—¬ìŠ¤ ì²´í¬ ì—”ë“œí¬ì¸íŠ¸:");
    println!("   GET /health          - ê¸°ë³¸ ìƒíƒœ");
    println!("   GET /health/detailed - ìƒì„¸ ìƒíƒœ");
    println!("   GET /ready           - ì¤€ë¹„ ìƒíƒœ");
    println!("   GET /live            - ìƒì¡´ í™•ì¸");

    app.listen(8080).await?;

    Ok(())
}
```

### ìë™ í—¬ìŠ¤ ì²´í¬

```rust
use orbital::application::OrbitApplication;

async fn periodic_health_check(app: &OrbitApplication) {
    let mut interval = tokio::time::interval(tokio::time::Duration::from_secs(30));

    loop {
        interval.tick().await;

        let status = app.status().await;
        let health_score = calculate_health_score(&status);

        println!("ğŸ’“ í—¬ìŠ¤ ì²´í¬ [{}]: ì ìˆ˜ {}/100",
            chrono::Utc::now().format("%H:%M:%S"),
            health_score
        );

        if health_score < 70 {
            println!("âš ï¸ ì„œë²„ ìƒíƒœ ì£¼ì˜: í—¬ìŠ¤ ì ìˆ˜ê°€ ë‚®ìŠµë‹ˆë‹¤");

            // í•„ìš”ì‹œ ì•Œë¦¼ ë°œì†¡
            send_health_alert(&status, health_score).await;
        }

        if health_score < 30 {
            println!("ğŸš¨ ì„œë²„ ìƒíƒœ ìœ„í—˜: ê¸´ê¸‰ ì¡°ì¹˜ í•„ìš”");

            // ìë™ ë³µêµ¬ ì‹œë„
            attempt_auto_recovery(app).await;
        }
    }
}

fn calculate_health_score(status: &orbital::application::ApplicationStatus) -> u32 {
    let mut score = 100u32;

    // ì—°ê²° ìƒíƒœ ì ìˆ˜ (40ì  ë§Œì )
    if status.active_connections > 0 {
        let health_ratio = status.healthy_connections as f64 / status.active_connections as f64;
        score = score.saturating_sub((40.0 * (1.0 - health_ratio)) as u32);
    }

    // ì‹¤í–‰ ìƒíƒœ ì ìˆ˜ (30ì  ë§Œì )
    if !status.is_running {
        score = score.saturating_sub(30);
    }

    // ì¶”ê°€ ë©”íŠ¸ë¦­ ê¸°ë°˜ ì ìˆ˜ ê³„ì‚° ê°€ëŠ¥
    // - ë©”ëª¨ë¦¬ ì‚¬ìš©ë¥ 
    // - CPU ì‚¬ìš©ë¥ 
    // - ì‘ë‹µ ì‹œê°„
    // - ì—ëŸ¬ ë¹„ìœ¨ ë“±

    score
}

async fn send_health_alert(status: &orbital::application::ApplicationStatus, score: u32) {
    println!("ğŸ“§ í—¬ìŠ¤ ì•Œë¦¼ ë°œì†¡: ì ìˆ˜ {} - {}", score, status.summary());

    // ì‹¤ì œë¡œëŠ” ì´ë©”ì¼, Slack, ë“±ìœ¼ë¡œ ì•Œë¦¼ ë°œì†¡
}

async fn attempt_auto_recovery(app: &OrbitApplication) {
    println!("ğŸ”§ ìë™ ë³µêµ¬ ì‹œë„ ì¤‘...");

    // ìë™ ë³µêµ¬ ë¡œì§
    // - ë©”ëª¨ë¦¬ ì •ë¦¬
    // - íƒ€ì„ì•„ì›ƒëœ ì—°ê²° ì •ë¦¬
    // - ìºì‹œ ì´ˆê¸°í™” ë“±

    tokio::time::sleep(tokio::time::Duration::from_secs(2)).await;
    println!("âœ… ìë™ ë³µêµ¬ ì™„ë£Œ");
}

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    let app = OrbitApplication::new(
        Some("Auto Health Check Server".to_string()),
        None,
        None
    );

    // ë°±ê·¸ë¼ìš´ë“œì—ì„œ í—¬ìŠ¤ ì²´í¬ ì‹¤í–‰
    let app_clone = app.clone();
    tokio::spawn(async move {
        periodic_health_check(&app_clone).await;
    });

    app.listen(8080).await?;

    Ok(())
}
```

## í”„ë¡œì„¸ìŠ¤ ê´€ë¦¬

### PID íŒŒì¼ ê´€ë¦¬

```rust
use orbital::application::OrbitApplication;
use std::fs;
use std::io::Write;

fn write_pid_file(path: &str) -> Result<(), Box<dyn std::error::Error>> {
    let pid = std::process::id();
    fs::write(path, pid.to_string())?;
    println!("ğŸ“ PID íŒŒì¼ ìƒì„±: {} (PID: {})", path, pid);
    Ok(())
}

fn remove_pid_file(path: &str) {
    if fs::remove_file(path).is_ok() {
        println!("ğŸ—‘ï¸ PID íŒŒì¼ ì‚­ì œ: {}", path);
    }
}

fn check_existing_process(path: &str) -> Result<bool, Box<dyn std::error::Error>> {
    if let Ok(pid_str) = fs::read_to_string(path) {
        if let Ok(pid) = pid_str.trim().parse::<u32>() {
            // í”„ë¡œì„¸ìŠ¤ ì¡´ì¬ ì—¬ë¶€ í™•ì¸ (Unix ì‹œìŠ¤í…œ)
            let output = std::process::Command::new("kill")
                .arg("-0")
                .arg(pid.to_string())
                .output();

            match output {
                Ok(result) => Ok(result.status.success()),
                Err(_) => Ok(false),
            }
        } else {
            Ok(false)
        }
    } else {
        Ok(false)
    }
}

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    let pid_file_path = "/var/run/orbital-server.pid";

    // ê¸°ì¡´ í”„ë¡œì„¸ìŠ¤ í™•ì¸
    if check_existing_process(pid_file_path)? {
        eprintln!("âŒ ë‹¤ë¥¸ ì„œë²„ ì¸ìŠ¤í„´ìŠ¤ê°€ ì´ë¯¸ ì‹¤í–‰ ì¤‘ì…ë‹ˆë‹¤");
        std::process::exit(1);
    }

    // PID íŒŒì¼ ìƒì„±
    write_pid_file(pid_file_path)?;

    // ì¢…ë£Œ ì‹œ PID íŒŒì¼ ì •ë¦¬ë¥¼ ìœ„í•œ ê°€ë“œ ì„¤ì •
    let pid_file_guard = scopeguard::guard(pid_file_path.to_string(), |path| {
        remove_pid_file(&path);
    });

    let mut app = OrbitApplication::new(
        Some("PID Managed Server".to_string()),
        None,
        None
    );

    // ì„œë²„ ì‹¤í–‰
    tokio::select! {
        result = app.listen(8080) => {
            if let Err(e) = result {
                eprintln!("ì„œë²„ ì˜¤ë¥˜: {}", e);
            }
        }
        _ = tokio::signal::ctrl_c() => {
            println!("\nğŸ›‘ ì¢…ë£Œ ì‹ í˜¸ ìˆ˜ì‹ ");
            let closed_connections = app.stop().await;
            println!("âœ… {} ê°œì˜ ì—°ê²°ì´ ì•ˆì „í•˜ê²Œ ì¢…ë£Œë˜ì—ˆìŠµë‹ˆë‹¤", closed_connections);
        }
    }

    // PID íŒŒì¼ì€ ê°€ë“œì— ì˜í•´ ìë™ìœ¼ë¡œ ì •ë¦¬ë©ë‹ˆë‹¤
    drop(pid_file_guard);

    Ok(())
}
```

## ë‹¤ìŒ ë‹¨ê³„

ìƒëª…ì£¼ê¸° ê´€ë¦¬ì— ëŒ€í•´ ì•Œì•„ë³´ì•˜ë‹¤ë©´, ë‹¤ìŒ ë¬¸ì„œë“¤ì„ í™•ì¸í•´ë³´ì„¸ìš”:

- [ì—ëŸ¬ ì²˜ë¦¬](/docs/orbital/application/error-handling) - ì—ëŸ¬ ì²˜ë¦¬ì™€ ë³µêµ¬
- [ì„¤ì • ê´€ë¦¬](/docs/orbital/application/configuration) - ì• í”Œë¦¬ì¼€ì´ì…˜ ì„¤ì •
- [ìƒíƒœ ëª¨ë‹ˆí„°ë§](/docs/orbital/application/monitoring) - ì• í”Œë¦¬ì¼€ì´ì…˜ ìƒíƒœì™€ í†µê³„
