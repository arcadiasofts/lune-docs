---
title: 'ìƒíƒœ ëª¨ë‹ˆí„°ë§'
path: 'orbital/application/monitoring'
product: 'Orbital'
category: 'Application'
lastUpdate: 2025-09-05
order: 14
---

## ê°œìš”

Orbital ì• í”Œë¦¬ì¼€ì´ì…˜ì€ ì‹¤ì‹œê°„ ìƒíƒœ ëª¨ë‹ˆí„°ë§ê³¼ í†µê³„ ìˆ˜ì§‘ ê¸°ëŠ¥ì„ ì œê³µí•˜ì—¬ ì„œë²„ì˜ ì„±ëŠ¥ê³¼ ìƒíƒœë¥¼ ì§€ì†ì ìœ¼ë¡œ ê´€ì°°í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

## ì• í”Œë¦¬ì¼€ì´ì…˜ ìƒíƒœ ì¡°íšŒ

### ê¸°ë³¸ ìƒíƒœ ì •ë³´

```rust
use orbital::application::OrbitApplication;

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    let app = OrbitApplication::new(
        Some("Monitor Server".to_string()),
        None,
        None
    );

    // ìƒíƒœ ì •ë³´ ì¡°íšŒ
    let status = app.status().await;

    println!("ì• í”Œë¦¬ì¼€ì´ì…˜ ì •ë³´:");
    println!("  ì´ë¦„: {}", status.name);
    println!("  ë²„ì „: {}", status.version);
    println!("  ì‹¤í–‰ ì¤‘: {}", status.is_running);

    println!("ì—°ê²° ì •ë³´:");
    println!("  í™œì„± ì—°ê²°: {}", status.active_connections);
    println!("  ì •ìƒ ì—°ê²°: {}", status.healthy_connections);

    println!("ì—°ê²° í†µê³„:");
    println!("  {}", status.connection_stats.summary());

    // ìš”ì•½ ì •ë³´
    println!("ì „ì²´ ìš”ì•½: {}", status.summary());

    // ë¼ìš°í„° í†µê³„
    let router_stats = app.router_statistics();
    for stat in router_stats {
        println!("ë¼ìš°í„° '{}': {}", stat.name(), stat.summary());
    }

    Ok(())
}
```

### ì£¼ê¸°ì  ìƒíƒœ ëª¨ë‹ˆí„°ë§

```rust
use orbital::application::OrbitApplication;
use tokio::time::{interval, Duration};

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    let app = OrbitApplication::new(
        Some("Monitoring Server".to_string()),
        None,
        None
    );

    // ë°±ê·¸ë¼ìš´ë“œ ëª¨ë‹ˆí„°ë§ íƒœìŠ¤í¬
    let app_clone = app.clone();
    tokio::spawn(async move {
        let mut interval = interval(Duration::from_secs(30));

        loop {
            interval.tick().await;

            let status = app_clone.status().await;

            println!("ğŸ” ìƒíƒœ ì²´í¬ [{}]", chrono::Utc::now().format("%H:%M:%S"));
            println!("  í™œì„± ì—°ê²°: {}", status.active_connections);
            println!("  ì •ìƒ ì—°ê²°: {}", status.healthy_connections);

            // ì—°ê²° ìƒíƒœê°€ ì¢‹ì§€ ì•Šìœ¼ë©´ ê²½ê³ 
            if status.active_connections > 0 {
                let health_ratio = status.healthy_connections as f64 / status.active_connections as f64;
                if health_ratio < 0.8 {
                    println!("âš ï¸  ì—°ê²° ìƒíƒœ ì£¼ì˜: ì •ìƒ ì—°ê²° ë¹„ìœ¨ {:.1}%", health_ratio * 100.0);
                }
            }

            println!();
        }
    });

    app.listen(8080).await?;

    Ok(())
}
```

## ì—°ê²° ê´€ë¦¬ ëª¨ë‹ˆí„°ë§

### ì—°ê²° í†µê³„ ì¶”ì 

```rust
use orbital::application::OrbitApplication;

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    let app = OrbitApplication::new(None, None, None);
    let connection_manager = app.connection_manager();

    // ì—°ê²° í†µê³„ ëª¨ë‹ˆí„°ë§
    tokio::spawn(async move {
        loop {
            let stats = connection_manager.statistics().await;
            println!("ğŸ“Š ì—°ê²° í†µê³„: {}", stats.summary());

            // í•˜íŠ¸ë¹„íŠ¸ ìƒíƒœ í™•ì¸
            let heartbeat_statuses = connection_manager.heartbeat_statuses().await;
            let healthy_count = heartbeat_statuses.iter()
                .filter(|s| !s.is_timeout)
                .count();

            println!("ğŸ’“ ì •ìƒ ì—°ê²°: {}/{}", healthy_count, heartbeat_statuses.len());

            // ê°œë³„ ì—°ê²° ìƒíƒœ ì¶œë ¥ (ì²˜ìŒ 5ê°œë§Œ)
            for (i, status) in heartbeat_statuses.iter().take(5).enumerate() {
                let status_icon = if status.is_timeout { "âŒ" } else { "âœ…" };
                println!("  {} ì—°ê²° {}: ì§€ì—°ì‹œê°„ {}ms",
                    status_icon,
                    status.connection_id,
                    status.latency_ms
                );
            }

            if heartbeat_statuses.len() > 5 {
                println!("  ... ë° {} ê°œ ì¶”ê°€ ì—°ê²°", heartbeat_statuses.len() - 5);
            }

            tokio::time::sleep(tokio::time::Duration::from_secs(30)).await;
        }
    });

    app.listen(8080).await?;

    Ok(())
}
```

### ì—°ê²° ì´ë²¤íŠ¸ ëª¨ë‹ˆí„°ë§

```rust
use orbital::application::OrbitApplication;
use orbital::event::{EventListener, EventCallback};
use std::sync::{Arc, Mutex};
use std::collections::HashMap;

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    let app = OrbitApplication::new(
        Some("Connection Monitor".to_string()),
        None,
        None
    );

    let emitter = app.event_emitter();

    // ì—°ê²° í†µê³„ ì €ì¥ì†Œ
    let connection_stats = Arc::new(Mutex::new(HashMap::<String, u64>::new()));

    // ì—°ê²° ì´ë²¤íŠ¸ ì¶”ì 
    let stats_clone = Arc::clone(&connection_stats);
    let connection_callback: EventCallback = Arc::new(move |event_data| {
        let mut stats = stats_clone.lock().unwrap();

        match event_data.name() {
            "connection:new" => {
                *stats.entry("new_connections".to_string()).or_insert(0) += 1;
                println!("ğŸ”— ìƒˆ ì—°ê²°: {}", event_data.payload().get("connection_id").unwrap_or(&serde_json::Value::Null));
            },
            "connection:closed" => {
                *stats.entry("closed_connections".to_string()).or_insert(0) += 1;
                println!("ğŸ”Œ ì—°ê²° ì¢…ë£Œ: {}", event_data.payload().get("connection_id").unwrap_or(&serde_json::Value::Null));
            },
            "connection:heartbeat_timeout" => {
                *stats.entry("timeout_connections".to_string()).or_insert(0) += 1;
                println!("ğŸ’” í•˜íŠ¸ë¹„íŠ¸ íƒ€ì„ì•„ì›ƒ: {}", event_data.payload().get("connection_id").unwrap_or(&serde_json::Value::Null));
            },
            _ => {}
        }

        // í†µê³„ ì¶œë ¥ (10ê°œ ì´ë²¤íŠ¸ë§ˆë‹¤)
        let total_events: u64 = stats.values().sum();
        if total_events % 10 == 0 {
            println!("ğŸ“ˆ ì—°ê²° í†µê³„ ì—…ë°ì´íŠ¸:");
            for (event_type, count) in stats.iter() {
                println!("  {}: {} íšŒ", event_type, count);
            }
            println!();
        }

        Ok(())
    });

    // ì—°ê²° ê´€ë ¨ ëª¨ë“  ì´ë²¤íŠ¸ ìˆ˜ì‹ 
    let connection_events = vec![
        "connection:new",
        "connection:closed",
        "connection:heartbeat_timeout"
    ];

    for event_name in connection_events {
        let listener = EventListener::new(event_name, Arc::clone(&connection_callback));
        emitter.add_listener(listener)?;
    }

    app.listen(8080).await?;

    Ok(())
}
```

## ì„±ëŠ¥ ë©”íŠ¸ë¦­

### ë¼ìš°í„° ì„±ëŠ¥ ëª¨ë‹ˆí„°ë§

```rust
use orbital::application::OrbitApplication;
use orbital::router::{Router, RouteResponse};
use orbital::event::{EventListener, EventCallback};
use serde_json::json;
use std::sync::{Arc, Mutex};
use std::collections::HashMap;
use std::time::Instant;

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    let mut app = OrbitApplication::new(
        Some("Performance Monitor".to_string()),
        None,
        None
    );

    // ì„±ëŠ¥ ë©”íŠ¸ë¦­ ì €ì¥ì†Œ
    let performance_metrics = Arc::new(Mutex::new(HashMap::<String, Vec<u128>>::new()));

    // ë¼ìš°í„° ì„±ëŠ¥ ì¶”ì ì„ ìœ„í•œ ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ
    let emitter = app.event_emitter();
    let metrics_clone = Arc::clone(&performance_metrics);

    let route_callback: EventCallback = Arc::new(move |event_data| {
        if event_data.name() == "route:matched" {
            if let Some(handler_time) = event_data.payload().get("handler_time_ms") {
                if let Some(path) = event_data.payload().get("path") {
                    let mut metrics = metrics_clone.lock().unwrap();
                    let route_path = path.as_str().unwrap_or("unknown").to_string();
                    let time_ms = handler_time.as_u64().unwrap_or(0) as u128;

                    metrics.entry(route_path.clone())
                        .or_insert_with(Vec::new)
                        .push(time_ms);

                    // 100ê°œ ìƒ˜í”Œë§ˆë‹¤ í†µê³„ ì¶œë ¥
                    if let Some(times) = metrics.get(&route_path) {
                        if times.len() % 100 == 0 {
                            let avg = times.iter().sum::<u128>() / times.len() as u128;
                            let min = *times.iter().min().unwrap_or(&0);
                            let max = *times.iter().max().unwrap_or(&0);

                            println!("ğŸ¯ ë¼ìš°íŠ¸ ì„±ëŠ¥ [{}]:", route_path);
                            println!("  í‰ê· : {}ms, ìµœì†Œ: {}ms, ìµœëŒ€: {}ms", avg, min, max);
                        }
                    }
                }
            }
        }
        Ok(())
    });

    let route_listener = EventListener::new("route:matched", route_callback);
    emitter.add_listener(route_listener)?;

    // í…ŒìŠ¤íŠ¸ìš© ë¼ìš°í„° ì¶”ê°€
    let mut test_router = Router::new("Performance Test Router");

    test_router.read("/fast", Arc::new(|_ctx| {
        // ë¹ ë¥¸ ì‘ë‹µ ì‹œë®¬ë ˆì´ì…˜
        Ok(RouteResponse::json(json!({"message": "Fast response"})))
    }));

    test_router.read("/slow", Arc::new(|_ctx| {
        // ëŠë¦° ì‘ë‹µ ì‹œë®¬ë ˆì´ì…˜
        std::thread::sleep(std::time::Duration::from_millis(100));
        Ok(RouteResponse::json(json!({"message": "Slow response"})))
    }));

    app.register(test_router)?;

    // ì£¼ê¸°ì  ì „ì²´ ì„±ëŠ¥ ë¦¬í¬íŠ¸
    let metrics_clone2 = Arc::clone(&performance_metrics);
    tokio::spawn(async move {
        let mut interval = tokio::time::interval(tokio::time::Duration::from_secs(60));

        loop {
            interval.tick().await;

            let metrics = metrics_clone2.lock().unwrap();
            if !metrics.is_empty() {
                println!("ğŸ“Š ì„±ëŠ¥ ë¦¬í¬íŠ¸ [{}]", chrono::Utc::now().format("%H:%M:%S"));

                for (route, times) in metrics.iter() {
                    if !times.is_empty() {
                        let avg = times.iter().sum::<u128>() / times.len() as u128;
                        let count = times.len();
                        println!("  {}: í‰ê·  {}ms ({} ìš”ì²­)", route, avg, count);
                    }
                }
                println!();
            }
        }
    });

    app.listen(8080).await?;

    Ok(())
}
```

### ë©”ëª¨ë¦¬ ë° ì‹œìŠ¤í…œ ë¦¬ì†ŒìŠ¤ ëª¨ë‹ˆí„°ë§

```rust
use orbital::application::OrbitApplication;
use sysinfo::{System, SystemExt, ProcessExt};
use tokio::time::{interval, Duration};

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    let app = OrbitApplication::new(
        Some("Resource Monitor".to_string()),
        None,
        None
    );

    // ì‹œìŠ¤í…œ ì •ë³´ ëª¨ë‹ˆí„°ë§
    tokio::spawn(async move {
        let mut sys = System::new_all();
        let mut interval = interval(Duration::from_secs(30));

        loop {
            interval.tick().await;
            sys.refresh_all();

            // ì „ì²´ ì‹œìŠ¤í…œ ë©”ëª¨ë¦¬
            let total_memory = sys.total_memory();
            let used_memory = sys.used_memory();
            let memory_usage_percent = (used_memory as f64 / total_memory as f64) * 100.0;

            // CPU ì‚¬ìš©ë¥ 
            let cpu_usage = sys.global_cpu_info().cpu_usage();

            // í˜„ì¬ í”„ë¡œì„¸ìŠ¤ ì •ë³´
            let current_pid = std::process::id();
            if let Some(process) = sys.process(sysinfo::Pid::from(current_pid as usize)) {
                let process_memory = process.memory();
                let process_cpu = process.cpu_usage();

                println!("ğŸ–¥ï¸  ì‹œìŠ¤í…œ ë¦¬ì†ŒìŠ¤ [{}]", chrono::Utc::now().format("%H:%M:%S"));
                println!("  ì „ì²´ ë©”ëª¨ë¦¬: {:.1}% ({} MB / {} MB)",
                    memory_usage_percent,
                    used_memory / 1024 / 1024,
                    total_memory / 1024 / 1024
                );
                println!("  CPU ì‚¬ìš©ë¥ : {:.1}%", cpu_usage);
                println!("  í”„ë¡œì„¸ìŠ¤ ë©”ëª¨ë¦¬: {} MB", process_memory / 1024 / 1024);
                println!("  í”„ë¡œì„¸ìŠ¤ CPU: {:.1}%", process_cpu);

                // ê²½ê³  ì„ê³„ê°’ ì²´í¬
                if memory_usage_percent > 80.0 {
                    println!("âš ï¸  ë©”ëª¨ë¦¬ ì‚¬ìš©ë¥  ë†’ìŒ: {:.1}%", memory_usage_percent);
                }
                if cpu_usage > 80.0 {
                    println!("âš ï¸  CPU ì‚¬ìš©ë¥  ë†’ìŒ: {:.1}%", cpu_usage);
                }
                if process_memory / 1024 / 1024 > 500 {
                    println!("âš ï¸  í”„ë¡œì„¸ìŠ¤ ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ ë†’ìŒ: {} MB", process_memory / 1024 / 1024);
                }

                println!();
            }
        }
    });

    app.listen(8080).await?;

    Ok(())
}
```

## ë¡œê·¸ ëª¨ë‹ˆí„°ë§

### êµ¬ì¡°í™”ëœ ë¡œê¹…ê³¼ ëª¨ë‹ˆí„°ë§

```rust
use orbital::application::{OrbitApplication, config::LogLevel};
use orbital::event::{EventListener, EventCallback};
use serde_json::json;
use std::sync::{Arc, Mutex};
use std::collections::HashMap;

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    let app = OrbitApplication::new(
        Some("Log Monitor".to_string()),
        None,
        None
    );

    // ë¡œê·¸ í†µê³„ ì €ì¥ì†Œ
    let log_stats = Arc::new(Mutex::new(HashMap::<String, u64>::new()));

    // ë¡œê·¸ ì´ë²¤íŠ¸ ëª¨ë‹ˆí„°ë§
    let emitter = app.event_emitter();
    let stats_clone = Arc::clone(&log_stats);

    let log_callback: EventCallback = Arc::new(move |event_data| {
        let mut stats = stats_clone.lock().unwrap();

        // ë¡œê·¸ ë ˆë²¨ë³„ ì¹´ìš´íŠ¸
        *stats.entry(event_data.name().to_string()).or_insert(0) += 1;

        // ì—ëŸ¬ ë¡œê·¸ëŠ” ì¦‰ì‹œ ì¶œë ¥
        if event_data.name() == "log:error" {
            println!("ğŸš¨ ì—ëŸ¬ ë¡œê·¸: {}", event_data.payload());
        }

        // ê²½ê³  ë¡œê·¸ë„ ì¶œë ¥
        if event_data.name() == "log:warn" {
            println!("âš ï¸  ê²½ê³  ë¡œê·¸: {}", event_data.payload());
        }

        // í†µê³„ ì—…ë°ì´íŠ¸ (50ê°œ ë¡œê·¸ë§ˆë‹¤)
        let total_logs: u64 = stats.values().sum();
        if total_logs % 50 == 0 {
            println!("ğŸ“ ë¡œê·¸ í†µê³„ (ì´ {} ê°œ):", total_logs);
            for (log_level, count) in stats.iter() {
                let percentage = (*count as f64 / total_logs as f64) * 100.0;
                println!("  {}: {} ê°œ ({:.1}%)", log_level, count, percentage);
            }
            println!();
        }

        Ok(())
    });

    // ëª¨ë“  ë¡œê·¸ ë ˆë²¨ ì´ë²¤íŠ¸ ìˆ˜ì‹ 
    let log_events = vec!["log:trace", "log:debug", "log:info", "log:warn", "log:error"];
    for event_name in log_events {
        let listener = EventListener::new(event_name, Arc::clone(&log_callback));
        emitter.add_listener(listener)?;
    }

    // ë‹¤ì–‘í•œ ë¡œê·¸ ìƒì„± (í…ŒìŠ¤íŠ¸ìš©)
    tokio::spawn({
        let app_clone = app.clone();
        async move {
            let mut interval = tokio::time::interval(tokio::time::Duration::from_secs(10));
            let mut counter = 0;

            loop {
                interval.tick().await;
                counter += 1;

                // ì£¼ê¸°ì ìœ¼ë¡œ ë‹¤ì–‘í•œ ë¡œê·¸ ìƒì„±
                app_clone.log(LogLevel::Info, "ì£¼ê¸°ì  ìƒíƒœ ì²´í¬", Some(json!({
                    "check_number": counter,
                    "timestamp": chrono::Utc::now().to_rfc3339()
                })));

                // ê°€ë” ê²½ê³ ë‚˜ ì—ëŸ¬ ë¡œê·¸ ìƒì„±
                if counter % 5 == 0 {
                    app_clone.log(LogLevel::Warn, "ì£¼ì˜ì‚¬í•­", Some(json!({
                        "warning_type": "periodic_warning",
                        "counter": counter
                    })));
                }

                if counter % 20 == 0 {
                    app_clone.log(LogLevel::Error, "í…ŒìŠ¤íŠ¸ ì—ëŸ¬", Some(json!({
                        "error_type": "test_error",
                        "counter": counter,
                        "severity": "low"
                    })));
                }
            }
        }
    });

    app.listen(8080).await?;

    Ok(())
}
```

## ëŒ€ì‹œë³´ë“œ ë° ë¦¬í¬íŒ…

### ì‹¤ì‹œê°„ ìƒíƒœ ëŒ€ì‹œë³´ë“œ

```rust
use orbital::application::OrbitApplication;
use serde_json::json;

async fn generate_status_report(app: &OrbitApplication) -> serde_json::Value {
    let status = app.status().await;
    let connection_manager = app.connection_manager();
    let connection_stats = connection_manager.statistics().await;
    let heartbeat_statuses = connection_manager.heartbeat_statuses().await;

    let healthy_connections = heartbeat_statuses.iter()
        .filter(|s| !s.is_timeout)
        .count();

    let average_latency = if !heartbeat_statuses.is_empty() {
        heartbeat_statuses.iter()
            .map(|s| s.latency_ms)
            .sum::<u64>() / heartbeat_statuses.len() as u64
    } else {
        0
    };

    json!({
        "timestamp": chrono::Utc::now().to_rfc3339(),
        "application": {
            "name": status.name,
            "version": status.version,
            "is_running": status.is_running,
            "uptime_seconds": 0 // ì‹¤ì œë¡œëŠ” ì‹œì‘ ì‹œê°„ìœ¼ë¡œë¶€í„° ê³„ì‚°
        },
        "connections": {
            "active": status.active_connections,
            "healthy": healthy_connections,
            "health_ratio": if status.active_connections > 0 {
                healthy_connections as f64 / status.active_connections as f64
            } else {
                1.0
            },
            "average_latency_ms": average_latency
        },
        "performance": {
            "total_requests": connection_stats.messages_processed(),
            "requests_per_second": 0.0, // ì‹¤ì œë¡œëŠ” ì‹œê°„ ìœˆë„ìš° ê¸°ë°˜ ê³„ì‚°
            "average_response_time_ms": 0 // ì‹¤ì œë¡œëŠ” ì‘ë‹µ ì‹œê°„ ì¶”ì  í•„ìš”
        },
        "router_statistics": app.router_statistics().iter().map(|stat| json!({
            "name": stat.name(),
            "route_count": stat.route_count(),
            "handled_requests": stat.handled_requests(),
            "failed_requests": stat.failed_requests(),
            "average_response_time_ms": stat.average_response_time_ms()
        })).collect::<Vec<_>>()
    })
}

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    let app = OrbitApplication::new(
        Some("Dashboard Server".to_string()),
        None,
        None
    );

    // ìƒíƒœ ë¦¬í¬íŠ¸ ìƒì„± ë° ì¶œë ¥
    let app_clone = app.clone();
    tokio::spawn(async move {
        let mut interval = tokio::time::interval(tokio::time::Duration::from_secs(60));

        loop {
            interval.tick().await;

            let report = generate_status_report(&app_clone).await;
            println!("ğŸ“Š ìƒíƒœ ë¦¬í¬íŠ¸:");
            println!("{}", serde_json::to_string_pretty(&report).unwrap());
            println!("{}", "=".repeat(50));
        }
    });

    app.listen(8080).await?;

    Ok(())
}
```

## ë‹¤ìŒ ë‹¨ê³„

ìƒíƒœ ëª¨ë‹ˆí„°ë§ì— ëŒ€í•´ ì•Œì•„ë³´ì•˜ë‹¤ë©´, ë‹¤ìŒ ë¬¸ì„œë“¤ì„ í™•ì¸í•´ë³´ì„¸ìš”:

- [ìƒëª…ì£¼ê¸° ê´€ë¦¬](/docs/orbital/application/lifecycle) - ì„œë²„ ì‹œì‘, ì¤‘ì§€, ì¬ì‹œì‘
- [ì—ëŸ¬ ì²˜ë¦¬](/docs/orbital/application/error-handling) - ì—ëŸ¬ ì²˜ë¦¬ì™€ ë³µêµ¬
- [ì„¤ì • ê´€ë¦¬](/docs/orbital/application/configuration) - ì• í”Œë¦¬ì¼€ì´ì…˜ ì„¤ì •
