---
title: 'ì´ë²¤íŠ¸ ì‹œìŠ¤í…œ'
path: 'orbital/application/events'
product: 'Orbital'
category: 'Application'
lastUpdate: 2025-09-05
order: 13
---

## ê°œìš”

Orbital ì• í”Œë¦¬ì¼€ì´ì…˜ì€ ê°•ë ¥í•œ ì´ë²¤íŠ¸ ì‹œìŠ¤í…œì„ í†µí•´ ì• í”Œë¦¬ì¼€ì´ì…˜ ì „ë°˜ì˜ ìƒíƒœ ë³€í™”ì™€ ë™ì‘ì„ ëª¨ë‹ˆí„°ë§í•˜ê³  ëŒ€ì‘í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

## ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ë“±ë¡

### ê¸°ë³¸ ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ

```rust
use orbital::application::OrbitApplication;
use orbital::event::{EventListener, EventCallback};
use std::sync::Arc;

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    let app = OrbitApplication::new(
        Some("Event Server".to_string()),
        None,
        None
    );

    // ì´ë²¤íŠ¸ ì—ë¯¸í„° ê°€ì ¸ì˜¤ê¸°
    let emitter = app.event_emitter();

    // ì—°ê²° ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ
    let connection_callback: EventCallback = Arc::new(|event_data| {
        println!("ğŸ”— ìƒˆë¡œìš´ ì—°ê²°: {}", event_data.payload());
        Ok(())
    });

    let connection_listener = EventListener::new("connection:new", connection_callback);
    emitter.add_listener(connection_listener)?;

    // ë¼ìš°í„° ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ
    let router_callback: EventCallback = Arc::new(|event_data| {
        println!("ğŸ›£ï¸ ë¼ìš°í„° ë“±ë¡: {}", event_data.payload());
        Ok(())
    });

    let router_listener = EventListener::new("router:registered", router_callback);
    emitter.add_listener(router_listener)?;

    // ì—ëŸ¬ ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ
    let error_callback: EventCallback = Arc::new(|event_data| {
        eprintln!("ğŸš¨ ì—ëŸ¬ ë°œìƒ: {}", event_data.payload());
        Ok(())
    });

    let error_listener = EventListener::new("log:error", error_callback);
    emitter.add_listener(error_listener)?;

    app.listen(8080).await?;

    Ok(())
}
```

### ë‹¤ì¤‘ ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ

```rust
use orbital::application::OrbitApplication;
use orbital::event::{EventListener, EventCallback};
use std::sync::Arc;

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    let app = OrbitApplication::new(
        Some("Multi-Event Server".to_string()),
        None,
        None
    );

    let emitter = app.event_emitter();

    // ëª¨ë“  ì—°ê²° ê´€ë ¨ ì´ë²¤íŠ¸ ì²˜ë¦¬
    let connection_events = vec![
        "connection:new",
        "connection:closed",
        "connection:heartbeat_timeout"
    ];

    for event_name in connection_events {
        let callback: EventCallback = Arc::new(move |event_data| {
            println!("ğŸ”— ì—°ê²° ì´ë²¤íŠ¸ [{}]: {}", event_data.name(), event_data.payload());
            Ok(())
        });

        let listener = EventListener::new(event_name, callback);
        emitter.add_listener(listener)?;
    }

    // ëª¨ë“  ë¡œê·¸ ì´ë²¤íŠ¸ ì²˜ë¦¬
    let log_events = vec![
        "log:info",
        "log:warn",
        "log:error",
        "log:debug"
    ];

    for event_name in log_events {
        let callback: EventCallback = Arc::new(move |event_data| {
            let level = event_data.name().split(':').nth(1).unwrap_or("unknown");
            println!("ğŸ“ [{}] {}", level.to_uppercase(), event_data.payload());
            Ok(())
        });

        let listener = EventListener::new(event_name, callback);
        emitter.add_listener(listener)?;
    }

    app.listen(8080).await?;

    Ok(())
}
```

## ì»¤ìŠ¤í…€ ì´ë²¤íŠ¸ ë°œìƒ

### ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§ ì´ë²¤íŠ¸

```rust
use orbital::application::OrbitApplication;
use serde_json::json;

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    let app = OrbitApplication::new(None, None, None);

    // ì‚¬ìš©ì ì•¡ì…˜ ì´ë²¤íŠ¸
    app.emit_event("user:login", json!({
        "user_id": 123,
        "username": "alice",
        "ip_address": "192.168.1.100",
        "timestamp": chrono::Utc::now().to_rfc3339(),
        "user_agent": "LUNE Client 1.0"
    }));

    // ì£¼ë¬¸ ìƒì„± ì´ë²¤íŠ¸
    app.emit_event("order:created", json!({
        "order_id": "ORD-001",
        "customer_id": 456,
        "total_amount": 99.99,
        "currency": "USD",
        "items": [
            {"product_id": "PROD-123", "quantity": 2, "price": 29.99},
            {"product_id": "PROD-456", "quantity": 1, "price": 39.99}
        ],
        "payment_method": "credit_card",
        "created_at": chrono::Utc::now().to_rfc3339()
    }));

    // ì‹œìŠ¤í…œ ì´ë²¤íŠ¸
    app.emit_event("system:maintenance", json!({
        "type": "scheduled",
        "start_time": "2023-12-01T02:00:00Z",
        "duration_minutes": 30,
        "affected_services": ["api", "websocket", "database"],
        "maintenance_reason": "Database optimization"
    }));

    Ok(())
}
```

### ì—ëŸ¬ ë° ì•Œë¦¼ ì´ë²¤íŠ¸

```rust
use orbital::application::OrbitApplication;
use serde_json::json;

fn emit_error_events(app: &OrbitApplication) {
    // ì¹˜ëª…ì  ì—ëŸ¬
    app.emit_event("error:critical", json!({
        "error_type": "database_connection_failed",
        "message": "Failed to connect to primary database",
        "details": {
            "host": "db.example.com",
            "port": 5432,
            "database": "production",
            "error_code": "CONNECTION_TIMEOUT"
        },
        "timestamp": chrono::Utc::now().to_rfc3339(),
        "requires_immediate_attention": true
    }));

    // ê²½ê³  ì´ë²¤íŠ¸
    app.emit_event("warning:performance", json!({
        "warning_type": "high_memory_usage",
        "message": "Memory usage exceeded 80% threshold",
        "current_usage_mb": 1024,
        "threshold_mb": 800,
        "suggested_action": "Consider garbage collection or memory optimization",
        "timestamp": chrono::Utc::now().to_rfc3339()
    }));

    // ì •ë³´ ì´ë²¤íŠ¸
    app.emit_event("info:metrics", json!({
        "metrics": {
            "active_connections": 150,
            "requests_per_second": 45.2,
            "average_response_time_ms": 120,
            "error_rate_percent": 0.5
        },
        "timestamp": chrono::Utc::now().to_rfc3339()
    }));
}
```

## ì´ë²¤íŠ¸ ì²˜ë¦¬ íŒ¨í„´

### ì´ë²¤íŠ¸ ì²´ì´ë‹

```rust
use orbital::application::OrbitApplication;
use orbital::event::{EventListener, EventCallback};
use serde_json::json;
use std::sync::Arc;

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    let app = OrbitApplication::new(None, None, None);
    let emitter = app.event_emitter();

    // ì£¼ë¬¸ ìƒì„± ì´ë²¤íŠ¸ ì²˜ë¦¬
    let order_created_callback: EventCallback = Arc::new({
        let app_clone = app.clone(); // appì„ í´ë¡ í•˜ì—¬ í´ë¡œì €ì—ì„œ ì‚¬ìš©
        move |event_data| {
            println!("ğŸ“¦ ì£¼ë¬¸ ìƒì„±ë¨: {}", event_data.payload());

            // ì—°ì‡„ ì´ë²¤íŠ¸ ë°œìƒ
            if let Some(order_id) = event_data.payload().get("order_id") {
                // ì¬ê³  í™•ì¸ ì´ë²¤íŠ¸
                app_clone.emit_event("inventory:check", json!({
                    "order_id": order_id,
                    "requested_by": "order_created_handler"
                }));

                // ê²°ì œ ì²˜ë¦¬ ì´ë²¤íŠ¸
                app_clone.emit_event("payment:process", json!({
                    "order_id": order_id,
                    "amount": event_data.payload().get("total_amount").unwrap_or(&json!(0.0))
                }));

                // ì´ë©”ì¼ ë°œì†¡ ì´ë²¤íŠ¸
                app_clone.emit_event("email:send", json!({
                    "template": "order_confirmation",
                    "recipient": event_data.payload().get("customer_email"),
                    "data": {
                        "order_id": order_id
                    }
                }));
            }

            Ok(())
        }
    });

    let order_listener = EventListener::new("order:created", order_created_callback);
    emitter.add_listener(order_listener)?;

    // ì¬ê³  í™•ì¸ ì´ë²¤íŠ¸ ì²˜ë¦¬
    let inventory_callback: EventCallback = Arc::new(|event_data| {
        println!("ğŸ“Š ì¬ê³  í™•ì¸: {}", event_data.payload());
        // ì‹¤ì œ ì¬ê³  í™•ì¸ ë¡œì§
        Ok(())
    });

    let inventory_listener = EventListener::new("inventory:check", inventory_callback);
    emitter.add_listener(inventory_listener)?;

    app.listen(8080).await?;

    Ok(())
}
```

### ë¹„ë™ê¸° ì´ë²¤íŠ¸ ì²˜ë¦¬

```rust
use orbital::event::{EventListener, EventCallback};
use tokio::time::{sleep, Duration};
use std::sync::Arc;

// ë¹„ë™ê¸° ì‘ì—…ì„ ìˆ˜í–‰í•˜ëŠ” ì´ë²¤íŠ¸ ì½œë°±
let async_callback: EventCallback = Arc::new(|event_data| {
    let data = event_data.clone();

    // ë³„ë„ íƒœìŠ¤í¬ì—ì„œ ë¹„ë™ê¸° ì²˜ë¦¬
    tokio::spawn(async move {
        println!("ğŸ”„ ë¹„ë™ê¸° ì²˜ë¦¬ ì‹œì‘: {}", data.name());

        // ì™¸ë¶€ API í˜¸ì¶œ ì‹œë®¬ë ˆì´ì…˜
        sleep(Duration::from_millis(500)).await;

        // ì´ë©”ì¼ ë°œì†¡ ì‹œë®¬ë ˆì´ì…˜
        if data.name() == "email:send" {
            println!("ğŸ“§ ì´ë©”ì¼ ë°œì†¡ ì™„ë£Œ");
        }

        // ë°ì´í„°ë² ì´ìŠ¤ ì €ì¥ ì‹œë®¬ë ˆì´ì…˜
        if data.name() == "data:save" {
            sleep(Duration::from_millis(200)).await;
            println!("ğŸ’¾ ë°ì´í„° ì €ì¥ ì™„ë£Œ");
        }

        println!("âœ… ë¹„ë™ê¸° ì²˜ë¦¬ ì™„ë£Œ: {}", data.name());
    });

    Ok(())
});
```

### ì´ë²¤íŠ¸ í•„í„°ë§

```rust
use orbital::event::{EventListener, EventCallback};
use std::sync::Arc;

// íŠ¹ì • ì¡°ê±´ì— ë§ëŠ” ì´ë²¤íŠ¸ë§Œ ì²˜ë¦¬
let filtered_callback: EventCallback = Arc::new(|event_data| {
    // VIP ì‚¬ìš©ìë§Œ ì²˜ë¦¬
    if let Some(user_data) = event_data.payload().get("user") {
        if let Some(is_vip) = user_data.get("is_vip") {
            if is_vip.as_bool().unwrap_or(false) {
                println!("ğŸ‘‘ VIP ì‚¬ìš©ì ì´ë²¤íŠ¸: {}", event_data.payload());

                // VIP ì „ìš© ì²˜ë¦¬
                return Ok(());
            }
        }
    }

    // ë†’ì€ ê¸ˆì•¡ì˜ ì£¼ë¬¸ë§Œ ì²˜ë¦¬
    if event_data.name() == "order:created" {
        if let Some(amount) = event_data.payload().get("total_amount") {
            if amount.as_f64().unwrap_or(0.0) > 1000.0 {
                println!("ğŸ’° ê³ ì•¡ ì£¼ë¬¸ ì´ë²¤íŠ¸: {}", event_data.payload());

                // ê³ ì•¡ ì£¼ë¬¸ ì „ìš© ì²˜ë¦¬ (ìŠ¹ì¸ ìš”ì²­ ë“±)
                return Ok(());
            }
        }
    }

    // ì¡°ê±´ì— ë§ì§€ ì•ŠëŠ” ì´ë²¤íŠ¸ëŠ” ë¬´ì‹œ
    Ok(())
});

let filtered_listener = EventListener::new("*", filtered_callback);  // ëª¨ë“  ì´ë²¤íŠ¸ ìˆ˜ì‹ 
```

## ì´ë²¤íŠ¸ í†µê³„ ë° ëª¨ë‹ˆí„°ë§

### ì´ë²¤íŠ¸ ì¹´ìš´í„°

```rust
use orbital::event::{EventListener, EventCallback};
use std::collections::HashMap;
use std::sync::{Arc, Mutex};

// ì´ë²¤íŠ¸ í†µê³„ ìˆ˜ì§‘
let event_counter = Arc::new(Mutex::new(HashMap::<String, u64>::new()));

let counter_clone = Arc::clone(&event_counter);
let stats_callback: EventCallback = Arc::new(move |event_data| {
    let mut counter = counter_clone.lock().unwrap();
    *counter.entry(event_data.name().to_string()).or_insert(0) += 1;

    // 100ê°œë§ˆë‹¤ í†µê³„ ì¶œë ¥
    let total: u64 = counter.values().sum();
    if total % 100 == 0 {
        println!("ğŸ“Š ì´ë²¤íŠ¸ í†µê³„ (ì´ {}ê°œ):", total);
        for (event_name, count) in counter.iter() {
            println!("  {}: {} íšŒ", event_name, count);
        }
        println!();
    }

    Ok(())
});

// ëª¨ë“  ì´ë²¤íŠ¸ì— ëŒ€í•´ í†µê³„ ìˆ˜ì§‘
let stats_listener = EventListener::new("*", stats_callback);
```

### ì„±ëŠ¥ ëª¨ë‹ˆí„°ë§

```rust
use orbital::event::{EventListener, EventCallback};
use std::time::Instant;
use std::sync::{Arc, Mutex};
use std::collections::HashMap;

// ì´ë²¤íŠ¸ ì²˜ë¦¬ ì‹œê°„ ì¸¡ì •
let processing_times = Arc::new(Mutex::new(HashMap::<String, Vec<u128>>::new()));

let times_clone = Arc::clone(&processing_times);
let perf_callback: EventCallback = Arc::new(move |event_data| {
    let start_time = Instant::now();

    // ì´ë²¤íŠ¸ ì²˜ë¦¬ ì‹œë®¬ë ˆì´ì…˜
    std::thread::sleep(std::time::Duration::from_millis(
        fastrand::u64(10..100) // 10-100ms ëœë¤ ì§€ì—°
    ));

    let elapsed = start_time.elapsed().as_millis();

    // ì²˜ë¦¬ ì‹œê°„ ê¸°ë¡
    let mut times = times_clone.lock().unwrap();
    times.entry(event_data.name().to_string())
        .or_insert_with(Vec::new)
        .push(elapsed);

    // 100ê°œ ìƒ˜í”Œë§ˆë‹¤ í‰ê·  ê³„ì‚°
    if let Some(samples) = times.get(event_data.name()) {
        if samples.len() % 100 == 0 {
            let avg = samples.iter().sum::<u128>() / samples.len() as u128;
            println!("â±ï¸ {} í‰ê·  ì²˜ë¦¬ ì‹œê°„: {}ms", event_data.name(), avg);
        }
    }

    Ok(())
});
```

## ì—ëŸ¬ ì²˜ë¦¬

### ì´ë²¤íŠ¸ ì²˜ë¦¬ ì—ëŸ¬ í•¸ë“¤ë§

```rust
use orbital::event::{EventListener, EventCallback, EventError};
use std::sync::Arc;

let error_handling_callback: EventCallback = Arc::new(|event_data| {
    match event_data.name() {
        "critical:error" => {
            // ì¤‘ìš”í•œ ì—ëŸ¬ ì²˜ë¦¬
            eprintln!("ğŸš¨ ì¹˜ëª…ì  ì˜¤ë¥˜: {}", event_data.payload());

            // ì•Œë¦¼ ë°œì†¡, ë¡œê·¸ ì €ì¥ ë“±
            // send_alert_notification(&event_data);
            // save_error_to_database(&event_data);

            // ì²˜ë¦¬ ì‹¤íŒ¨ ì‹œ ì—ëŸ¬ ë°˜í™˜
            if event_data.payload().get("severity").and_then(|v| v.as_str()) == Some("fatal") {
                return Err(EventError::ProcessingFailed(
                    "Fatal error requires immediate intervention".to_string()
                ));
            }
        },
        "user:action" => {
            // ì‚¬ìš©ì ì•¡ì…˜ ê²€ì¦
            if event_data.payload().get("user_id").is_none() {
                return Err(EventError::ProcessingFailed(
                    "User ID is required for user actions".to_string()
                ));
            }

            println!("ğŸ‘¤ ì‚¬ìš©ì ì•¡ì…˜: {}", event_data.payload());
        },
        _ => {
            // ì¼ë°˜ ì´ë²¤íŠ¸ ì²˜ë¦¬
            println!("ğŸ“ ì´ë²¤íŠ¸ ì²˜ë¦¬: {}", event_data.name());
        }
    }

    Ok(())
});
```

## ë‹¤ìŒ ë‹¨ê³„

ì´ë²¤íŠ¸ ì‹œìŠ¤í…œì— ëŒ€í•´ ì•Œì•„ë³´ì•˜ë‹¤ë©´, ë‹¤ìŒ ë¬¸ì„œë“¤ì„ í™•ì¸í•´ë³´ì„¸ìš”:

- [ìƒíƒœ ëª¨ë‹ˆí„°ë§](/docs/orbital/application/monitoring) - ì• í”Œë¦¬ì¼€ì´ì…˜ ìƒíƒœì™€ í†µê³„
- [ìƒëª…ì£¼ê¸° ê´€ë¦¬](/docs/orbital/application/lifecycle) - ì„œë²„ ì‹œì‘, ì¤‘ì§€, ì¬ì‹œì‘
- [ì—ëŸ¬ ì²˜ë¦¬](/docs/orbital/application/error-handling) - ì—ëŸ¬ ì²˜ë¦¬ì™€ ë³µêµ¬
