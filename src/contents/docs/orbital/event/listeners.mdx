---
title: 'ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ'
path: 'orbital/event/listeners'
product: 'Orbital'
category: 'Event'
lastUpdate: 2025-09-05
order: 32
---

## ê°œìš”

ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆëŠ” íŠ¹ì • ì´ë²¤íŠ¸ë¥¼ ìˆ˜ì‹ í•˜ê³  ì²˜ë¦¬í•˜ëŠ” í•µì‹¬ ì»´í¬ë„ŒíŠ¸ì…ë‹ˆë‹¤. ë‹¤ì–‘í•œ íŒ¨í„´ê³¼ ê³ ê¸‰ ê¸°ëŠ¥ì„ í™œìš©í•˜ì—¬ íš¨ìœ¨ì ì¸ ì´ë²¤íŠ¸ ì²˜ë¦¬ ì‹œìŠ¤í…œì„ êµ¬ì¶•í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

## ë¦¬ìŠ¤ë„ˆ ë“±ë¡ê³¼ ê´€ë¦¬

### ê¸°ë³¸ ë¦¬ìŠ¤ë„ˆ ë“±ë¡

```rust
use orbital::event::{EventListener, EventCallback, EventEmitter};
use std::sync::Arc;

let emitter = Arc::new(EventEmitter::new());

// ë‹¨ìˆœ ì½œë°± ë¦¬ìŠ¤ë„ˆ
let simple_callback: EventCallback = Arc::new(|event_data| {
    println!("ì´ë²¤íŠ¸ ìˆ˜ì‹ : {} - {}", event_data.name(), event_data.payload());
    Ok(())
});

let listener = EventListener::new("user:login", simple_callback);
let listener_id = emitter.add_listener(listener)?;

println!("ë¦¬ìŠ¤ë„ˆ ë“±ë¡ë¨, ID: {}", listener_id);
```

### ì—¬ëŸ¬ ë¦¬ìŠ¤ë„ˆ ê´€ë¦¬

```rust
use orbital::event::{EventListener, EventCallback, EventEmitter};
use std::sync::Arc;
use std::collections::HashMap;

struct ListenerManager {
    emitter: Arc<EventEmitter>,
    listeners: HashMap<String, String>, // name -> listener_id
}

impl ListenerManager {
    fn new() -> Self {
        Self {
            emitter: Arc::new(EventEmitter::new()),
            listeners: HashMap::new(),
        }
    }

    fn register_listener(&mut self, name: &str, event_name: &str, callback: EventCallback) -> Result<(), Box<dyn std::error::Error>> {
        let listener = EventListener::new(event_name, callback);
        let listener_id = self.emitter.add_listener(listener)?;
        self.listeners.insert(name.to_string(), listener_id);

        println!("ë¦¬ìŠ¤ë„ˆ '{}' ë“±ë¡: {} -> {}", name, event_name, listener_id);
        Ok(())
    }

    fn unregister_listener(&mut self, name: &str) -> Result<(), Box<dyn std::error::Error>> {
        if let Some(listener_id) = self.listeners.remove(name) {
            self.emitter.remove_listener(&listener_id)?;
            println!("ë¦¬ìŠ¤ë„ˆ '{}' ì œê±°ë¨", name);
        }
        Ok(())
    }

    fn list_listeners(&self) {
        println!("ë“±ë¡ëœ ë¦¬ìŠ¤ë„ˆë“¤:");
        for (name, id) in &self.listeners {
            println!("  {} -> {}", name, id);
        }
    }
}

// ì‚¬ìš© ì˜ˆì‹œ
let mut manager = ListenerManager::new();

manager.register_listener(
    "user_logger",
    "user:*",
    Arc::new(|event_data| {
        println!("ì‚¬ìš©ì ì´ë²¤íŠ¸: {}", event_data.name());
        Ok(())
    })
)?;

manager.register_listener(
    "error_handler",
    "error:*",
    Arc::new(|event_data| {
        eprintln!("ì—ëŸ¬ ì´ë²¤íŠ¸: {}", event_data.payload());
        Ok(())
    })
)?;

manager.list_listeners();
```

## ê³ ê¸‰ ë¦¬ìŠ¤ë„ˆ íŒ¨í„´

### ì¡°ê±´ë¶€ ë¦¬ìŠ¤ë„ˆ

```rust
use orbital::event::{EventListener, EventCallback};
use std::sync::Arc;

// ì¡°ê±´ë¶€ ì²˜ë¦¬ ë¦¬ìŠ¤ë„ˆ
let conditional_callback: EventCallback = Arc::new(|event_data| {
    match event_data.name() {
        "user:login" => {
            if let Some(user_type) = event_data.payload().get("user_type") {
                if user_type.as_str() == Some("premium") {
                    println!("ğŸŒŸ í”„ë¦¬ë¯¸ì—„ ì‚¬ìš©ì ë¡œê·¸ì¸: {}", event_data.payload());
                    // í”„ë¦¬ë¯¸ì—„ ì‚¬ìš©ì ì „ìš© ì²˜ë¦¬
                } else {
                    println!("ğŸ‘¤ ì¼ë°˜ ì‚¬ìš©ì ë¡œê·¸ì¸");
                }
            }
        },
        "user:logout" => {
            println!("ğŸ‘‹ ì‚¬ìš©ì ë¡œê·¸ì•„ì›ƒ");
        },
        _ => {
            println!("ğŸ” ê¸°íƒ€ ì‚¬ìš©ì ì´ë²¤íŠ¸: {}", event_data.name());
        }
    }
    Ok(())
});

let conditional_listener = EventListener::new("user:*", conditional_callback);
```

### ìƒíƒœ ê¸°ë°˜ ë¦¬ìŠ¤ë„ˆ

```rust
use orbital::event::{EventListener, EventCallback};
use std::sync::{Arc, Mutex};

// ìƒíƒœë¥¼ ìœ ì§€í•˜ëŠ” ë¦¬ìŠ¤ë„ˆ
struct StatefulListener {
    counter: Arc<Mutex<u32>>,
    threshold: u32,
}

impl StatefulListener {
    fn new(threshold: u32) -> Self {
        Self {
            counter: Arc::new(Mutex::new(0)),
            threshold,
        }
    }

    fn create_callback(&self) -> EventCallback {
        let counter = Arc::clone(&self.counter);
        let threshold = self.threshold;

        Arc::new(move |event_data| {
            let mut count = counter.lock().unwrap();
            *count += 1;

            if *count % threshold == 0 {
                println!("ğŸ¯ ì„ê³„ê°’ ë„ë‹¬! {} ë²ˆì§¸ ì´ë²¤íŠ¸: {}", count, event_data.name());
            } else {
                println!("ğŸ“Š ì´ë²¤íŠ¸ ì¹´ìš´íŠ¸: {} - {}", count, event_data.name());
            }

            Ok(())
        })
    }
}

// ì‚¬ìš© ì˜ˆì‹œ
let stateful_listener = StatefulListener::new(10);
let callback = stateful_listener.create_callback();
let listener = EventListener::new("*", callback);
```

### ë°°ì¹˜ ì²˜ë¦¬ ë¦¬ìŠ¤ë„ˆ

```rust
use orbital::event::{EventListener, EventCallback, EventData};
use std::sync::{Arc, Mutex};
use std::collections::VecDeque;
use tokio::time::{interval, Duration};

struct BatchListener {
    batch: Arc<Mutex<VecDeque<EventData>>>,
    batch_size: usize,
}

impl BatchListener {
    fn new(batch_size: usize) -> Self {
        let batch_listener = Self {
            batch: Arc::new(Mutex::new(VecDeque::new())),
            batch_size,
        };

        // ì£¼ê¸°ì ìœ¼ë¡œ ë°°ì¹˜ ì²˜ë¦¬
        let batch_clone = Arc::clone(&batch_listener.batch);
        let size = batch_size;
        tokio::spawn(async move {
            let mut interval = interval(Duration::from_secs(5));

            loop {
                interval.tick().await;
                let mut batch = batch_clone.lock().unwrap();

                if !batch.is_empty() {
                    println!("ğŸ”„ ë°°ì¹˜ ì²˜ë¦¬ ì‹œì‘ ({} ê°œ ì´ë²¤íŠ¸)", batch.len());

                    // ë°°ì¹˜ ì²˜ë¦¬ ë¡œì§
                    while let Some(event) = batch.pop_front() {
                        println!("  ì²˜ë¦¬ ì¤‘: {}", event.name());
                    }

                    println!("âœ… ë°°ì¹˜ ì²˜ë¦¬ ì™„ë£Œ");
                }
            }
        });

        batch_listener
    }

    fn create_callback(&self) -> EventCallback {
        let batch = Arc::clone(&self.batch);
        let batch_size = self.batch_size;

        Arc::new(move |event_data| {
            let mut batch_queue = batch.lock().unwrap();
            batch_queue.push_back(event_data.clone());

            // ë°°ì¹˜ í¬ê¸°ì— ë„ë‹¬í•˜ë©´ ì¦‰ì‹œ ì²˜ë¦¬
            if batch_queue.len() >= batch_size {
                println!("ğŸš€ ë°°ì¹˜ í¬ê¸° ë„ë‹¬, ì¦‰ì‹œ ì²˜ë¦¬ ì‹œì‘");

                while let Some(event) = batch_queue.pop_front() {
                    println!("  ì¦‰ì‹œ ì²˜ë¦¬: {}", event.name());
                }
            }

            Ok(())
        })
    }
}

// ì‚¬ìš© ì˜ˆì‹œ
let batch_listener = BatchListener::new(5);
let callback = batch_listener.create_callback();
let listener = EventListener::new("batch:*", callback);
```

## ë¦¬ìŠ¤ë„ˆ ì²´ì¸

### ìˆœì°¨ ì²˜ë¦¬ ì²´ì¸

```rust
use orbital::event::{EventListener, EventCallback, EventData};
use std::sync::Arc;

struct ListenerChain {
    handlers: Vec<EventCallback>,
}

impl ListenerChain {
    fn new() -> Self {
        Self {
            handlers: Vec::new(),
        }
    }

    fn add_handler(mut self, handler: EventCallback) -> Self {
        self.handlers.push(handler);
        self
    }

    fn create_callback(self) -> EventCallback {
        Arc::new(move |event_data| {
            for (index, handler) in self.handlers.iter().enumerate() {
                println!("ğŸ”— ì²´ì¸ ë‹¨ê³„ {} ì‹¤í–‰", index + 1);

                if let Err(e) = handler(event_data.clone()) {
                    eprintln!("âŒ ì²´ì¸ ë‹¨ê³„ {} ì‹¤íŒ¨: {}", index + 1, e);
                    return Err(e);
                }
            }

            println!("âœ… ì²´ì¸ ì²˜ë¦¬ ì™„ë£Œ");
            Ok(())
        })
    }
}

// ì²´ì¸ êµ¬ì„±
let chain_callback = ListenerChain::new()
    .add_handler(Arc::new(|event_data| {
        println!("1ï¸âƒ£ ê²€ì¦ ë‹¨ê³„: {}", event_data.name());
        // ê²€ì¦ ë¡œì§
        Ok(())
    }))
    .add_handler(Arc::new(|event_data| {
        println!("2ï¸âƒ£ ë³€í™˜ ë‹¨ê³„: {}", event_data.name());
        // ë°ì´í„° ë³€í™˜ ë¡œì§
        Ok(())
    }))
    .add_handler(Arc::new(|event_data| {
        println!("3ï¸âƒ£ ì €ì¥ ë‹¨ê³„: {}", event_data.name());
        // ë°ì´í„° ì €ì¥ ë¡œì§
        Ok(())
    }))
    .create_callback();

let chain_listener = EventListener::new("data:process", chain_callback);
```

### ë³‘ë ¬ ì²˜ë¦¬ ì²´ì¸

```rust
use orbital::event::{EventListener, EventCallback};
use std::sync::Arc;
use tokio::task::JoinSet;

struct ParallelListenerChain {
    handlers: Vec<EventCallback>,
}

impl ParallelListenerChain {
    fn new() -> Self {
        Self {
            handlers: Vec::new(),
        }
    }

    fn add_handler(mut self, handler: EventCallback) -> Self {
        self.handlers.push(handler);
        self
    }

    fn create_callback(self) -> EventCallback {
        Arc::new(move |event_data| {
            let mut join_set = JoinSet::new();

            // ëª¨ë“  í•¸ë“¤ëŸ¬ë¥¼ ë³‘ë ¬ë¡œ ì‹¤í–‰
            for (index, handler) in self.handlers.iter().enumerate() {
                let handler_clone = Arc::clone(handler);
                let data_clone = event_data.clone();

                join_set.spawn(async move {
                    println!("ğŸš€ ë³‘ë ¬ ì²˜ë¦¬ {} ì‹œì‘", index + 1);
                    let result = handler_clone(data_clone);
                    println!("âœ… ë³‘ë ¬ ì²˜ë¦¬ {} ì™„ë£Œ", index + 1);
                    result
                });
            }

            // ëª¨ë“  í•¸ë“¤ëŸ¬ ì™„ë£Œ ëŒ€ê¸°
            tokio::spawn(async move {
                let mut success_count = 0;
                let mut error_count = 0;

                while let Some(result) = join_set.join_next().await {
                    match result {
                        Ok(Ok(())) => success_count += 1,
                        Ok(Err(e)) => {
                            error_count += 1;
                            eprintln!("âŒ ë³‘ë ¬ ì²˜ë¦¬ ì‹¤íŒ¨: {}", e);
                        },
                        Err(e) => {
                            error_count += 1;
                            eprintln!("âŒ íƒœìŠ¤í¬ ì‹¤íŒ¨: {}", e);
                        }
                    }
                }

                println!("ğŸ“Š ë³‘ë ¬ ì²˜ë¦¬ ê²°ê³¼: ì„±ê³µ {}, ì‹¤íŒ¨ {}", success_count, error_count);
            });

            Ok(())
        })
    }
}

// ë³‘ë ¬ ì²´ì¸ êµ¬ì„±
let parallel_callback = ParallelListenerChain::new()
    .add_handler(Arc::new(|event_data| {
        println!("ğŸ“§ ì´ë©”ì¼ ë°œì†¡ ì²˜ë¦¬: {}", event_data.name());
        std::thread::sleep(std::time::Duration::from_millis(100));
        Ok(())
    }))
    .add_handler(Arc::new(|event_data| {
        println!("ğŸ“± í‘¸ì‹œ ì•Œë¦¼ ì²˜ë¦¬: {}", event_data.name());
        std::thread::sleep(std::time::Duration::from_millis(80));
        Ok(())
    }))
    .add_handler(Arc::new(|event_data| {
        println!("ğŸ“Š ë¶„ì„ ë°ì´í„° ì „ì†¡: {}", event_data.name());
        std::thread::sleep(std::time::Duration::from_millis(50));
        Ok(())
    }))
    .create_callback();

let parallel_listener = EventListener::new("notification:send", parallel_callback);
```

## ë¦¬ìŠ¤ë„ˆ ì„±ëŠ¥ ìµœì í™”

### ë¹„ë™ê¸° ë¦¬ìŠ¤ë„ˆ

```rust
use orbital::event::{EventListener, EventCallback};
use std::sync::Arc;
use tokio::time::{sleep, Duration};

// ë¹„ë™ê¸° ì²˜ë¦¬ ë¦¬ìŠ¤ë„ˆ
let async_callback: EventCallback = Arc::new(|event_data| {
    let data = event_data.clone();

    // ë°±ê·¸ë¼ìš´ë“œì—ì„œ ë¹„ë™ê¸° ì²˜ë¦¬
    tokio::spawn(async move {
        println!("ğŸ”„ ë¹„ë™ê¸° ì²˜ë¦¬ ì‹œì‘: {}", data.name());

        // ì™¸ë¶€ API í˜¸ì¶œ ì‹œë®¬ë ˆì´ì…˜
        sleep(Duration::from_millis(200)).await;

        // ë°ì´í„°ë² ì´ìŠ¤ ì €ì¥ ì‹œë®¬ë ˆì´ì…˜
        sleep(Duration::from_millis(100)).await;

        println!("âœ… ë¹„ë™ê¸° ì²˜ë¦¬ ì™„ë£Œ: {}", data.name());
    });

    // ì¦‰ì‹œ ë°˜í™˜í•˜ì—¬ ë¸”ë¡œí‚¹ ë°©ì§€
    Ok(())
});

let async_listener = EventListener::new("async:*", async_callback);
```

### ìš°ì„ ìˆœìœ„ ê¸°ë°˜ ë¦¬ìŠ¤ë„ˆ

```rust
use orbital::event::{EventListener, EventCallback, EventData};
use std::sync::{Arc, Mutex};
use std::collections::BinaryHeap;
use std::cmp::Ordering;

#[derive(Clone)]
struct PriorityEvent {
    event: EventData,
    priority: u8, // ë†’ì„ìˆ˜ë¡ ìš°ì„ ìˆœìœ„ ë†’ìŒ
}

impl PartialEq for PriorityEvent {
    fn eq(&self, other: &Self) -> bool {
        self.priority == other.priority
    }
}

impl Eq for PriorityEvent {}

impl PartialOrd for PriorityEvent {
    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {
        Some(self.cmp(other))
    }
}

impl Ord for PriorityEvent {
    fn cmp(&self, other: &Self) -> Ordering {
        self.priority.cmp(&other.priority)
    }
}

struct PriorityListener {
    queue: Arc<Mutex<BinaryHeap<PriorityEvent>>>,
}

impl PriorityListener {
    fn new() -> Self {
        let listener = Self {
            queue: Arc::new(Mutex::new(BinaryHeap::new())),
        };

        // ë°±ê·¸ë¼ìš´ë“œ ì²˜ë¦¬ê¸°
        let queue_clone = Arc::clone(&listener.queue);
        tokio::spawn(async move {
            loop {
                tokio::time::sleep(Duration::from_millis(100)).await;

                let mut queue = queue_clone.lock().unwrap();
                if let Some(priority_event) = queue.pop() {
                    drop(queue); // ë½ í•´ì œ

                    println!("ğŸ¯ ìš°ì„ ìˆœìœ„ {} ì´ë²¤íŠ¸ ì²˜ë¦¬: {}",
                        priority_event.priority,
                        priority_event.event.name()
                    );

                    // ìš°ì„ ìˆœìœ„ì— ë”°ë¥¸ ì²˜ë¦¬
                    match priority_event.priority {
                        9..=10 => {
                            println!("ğŸš¨ ê¸´ê¸‰ ì²˜ë¦¬");
                            // ì¦‰ì‹œ ì²˜ë¦¬
                        },
                        6..=8 => {
                            println!("âš¡ ë†’ì€ ìš°ì„ ìˆœìœ„ ì²˜ë¦¬");
                            // ë¹ ë¥¸ ì²˜ë¦¬
                        },
                        3..=5 => {
                            println!("ğŸ“‹ ì¼ë°˜ ì²˜ë¦¬");
                            // ì¼ë°˜ ì²˜ë¦¬
                        },
                        _ => {
                            println!("ğŸŒ ë‚®ì€ ìš°ì„ ìˆœìœ„ ì²˜ë¦¬");
                            // ì§€ì—° ì²˜ë¦¬
                            tokio::time::sleep(Duration::from_millis(50)).await;
                        }
                    }
                }
            }
        });

        listener
    }

    fn create_callback(&self) -> EventCallback {
        let queue = Arc::clone(&self.queue);

        Arc::new(move |event_data| {
            // ì´ë²¤íŠ¸ íƒ€ì…ì— ë”°ë¥¸ ìš°ì„ ìˆœìœ„ ê²°ì •
            let priority = match event_data.name() {
                name if name.contains("critical") => 10,
                name if name.contains("error") => 8,
                name if name.contains("warning") => 6,
                name if name.contains("user") => 4,
                _ => 2,
            };

            let priority_event = PriorityEvent {
                event: event_data.clone(),
                priority,
            };

            let mut queue_guard = queue.lock().unwrap();
            queue_guard.push(priority_event);

            println!("ğŸ“¥ ì´ë²¤íŠ¸ íì— ì¶”ê°€ (ìš°ì„ ìˆœìœ„: {}): {}", priority, event_data.name());

            Ok(())
        })
    }
}

// ì‚¬ìš© ì˜ˆì‹œ
let priority_listener = PriorityListener::new();
let callback = priority_listener.create_callback();
let listener = EventListener::new("*", callback);
```

## ë¦¬ìŠ¤ë„ˆ ë””ë²„ê¹…

### ë””ë²„ê·¸ ë¦¬ìŠ¤ë„ˆ

```rust
use orbital::event::{EventListener, EventCallback};
use std::sync::Arc;
use std::time::Instant;

struct DebugListener {
    name: String,
}

impl DebugListener {
    fn new(name: &str) -> Self {
        Self {
            name: name.to_string(),
        }
    }

    fn create_callback(&self) -> EventCallback {
        let name = self.name.clone();

        Arc::new(move |event_data| {
            let start_time = Instant::now();

            println!("ğŸ” [{}] ì´ë²¤íŠ¸ ì²˜ë¦¬ ì‹œì‘: {}", name, event_data.name());
            println!("ğŸ“„ [{}] í˜ì´ë¡œë“œ í¬ê¸°: {} bytes",
                name,
                event_data.payload().to_string().len()
            );

            // ì‹¤ì œ ì²˜ë¦¬ ë¡œì§ (ì‹œë®¬ë ˆì´ì…˜)
            std::thread::sleep(std::time::Duration::from_millis(10));

            let elapsed = start_time.elapsed();
            println!("â±ï¸ [{}] ì²˜ë¦¬ ì‹œê°„: {:?}", name, elapsed);

            // ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ ì²´í¬ (ê°„ë‹¨í•œ ì˜ˆì‹œ)
            if elapsed.as_millis() > 100 {
                println!("âš ï¸ [{}] ì²˜ë¦¬ ì‹œê°„ì´ ê¸´ ì´ë²¤íŠ¸ ê°ì§€", name);
            }

            Ok(())
        })
    }
}

// ë””ë²„ê·¸ ë¦¬ìŠ¤ë„ˆ ì‚¬ìš©
let debug_listener = DebugListener::new("UserEventDebugger");
let debug_callback = debug_listener.create_callback();
let listener = EventListener::new("user:*", debug_callback);
```

## ë‹¤ìŒ ë‹¨ê³„

ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆì— ëŒ€í•´ ì•Œì•„ë³´ì•˜ë‹¤ë©´, ë‹¤ìŒ ë¬¸ì„œë“¤ì„ í™•ì¸í•´ë³´ì„¸ìš”:

- [ì»¤ìŠ¤í…€ ì´ë²¤íŠ¸](/docs/orbital/event/custom-events) - ì»¤ìŠ¤í…€ ì´ë²¤íŠ¸ ìƒì„±ê³¼ ì²˜ë¦¬
- [ì´ë²¤íŠ¸ íŒ¨í„´](/docs/orbital/event/patterns) - ì´ë²¤íŠ¸ ì²´ì´ë‹ê³¼ í•„í„°ë§
- [ì„±ëŠ¥ ìµœì í™”](/docs/orbital/event/performance) - ì´ë²¤íŠ¸ ì‹œìŠ¤í…œ ìµœì í™”
- [Event System ì‹œì‘í•˜ê¸°](/docs/orbital/event/getting-started) - ê¸°ë³¸ ì‚¬ìš©ë²•
