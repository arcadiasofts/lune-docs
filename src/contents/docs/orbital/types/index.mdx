---
title: 'Types & Data Structures 개요'
path: 'orbital/types/index'
product: 'Orbital'
category: 'Types'
lastUpdate: 2025-09-05
order: 40
---

## Orbital Types

Orbital은 강력한 타입 시스템을 제공하여 컴파일 타임에 많은 오류를 방지하고 안전한 코드 작성을 도와줍니다. LUNE 프로토콜 구조체부터 애플리케이션 설정까지 다양한 타입을 제공합니다.

## 주요 타입 카테고리

- **LUNE 프로토콜 구조체**: 메시지와 헤더 구조
- **애플리케이션 타입**: 설정과 상태 관리
- **라우터 타입**: 요청과 응답 처리
- **이벤트 타입**: 이벤트 시스템 구조
- **에러 타입**: 에러 처리와 복구

## 빠른 시작

### LUNE 메시지 생성

```rust
use orbital::r#struct::LUNE;
use chrono::Utc;

let mut lune_message = LUNE::new();

// 헤더 설정
lune_message.set_status(200);
lune_message.set_origin("client".to_string());
lune_message.set_nonce("abc123".to_string());
lune_message.set_type("api_request".to_string());
lune_message.set_datetime(Utc::now());

// 바디 설정
let body_data = serde_json::json!({
    "path": "/api/users",
    "method": "READ"
});
lune_message.set_body(body_data.to_string().into_bytes());
```

### 애플리케이션 상태 조회

```rust
use orbital::application::OrbitApplication;

let app = OrbitApplication::new(None, None, None);
let status = app.status().await;

println!("애플리케이션: {} v{}", status.name, status.version);
println!("활성 연결: {}", status.active_connections);
println!("정상 연결: {}", status.healthy_connections);
```

## 문서 목차

### 프로토콜 타입

- [LUNE 구조체](/docs/orbital/types/lune-protocol) - LUNE 메시지와 헤더 구조
- [직렬화](/docs/orbital/types/serialization) - 메시지 직렬화와 역직렬화

### 애플리케이션 타입

- [설정 타입](/docs/orbital/types/configuration) - ApplicationConfig와 관련 구조체
- [상태 타입](/docs/orbital/types/status) - ApplicationStatus와 통계 구조체

### 라우터 타입

- [요청/응답 타입](/docs/orbital/types/request-response) - RouteContext와 RouteResponse
- [라우터 통계](/docs/orbital/types/router-stats) - RouterStatistics와 성능 메트릭

### 이벤트 타입

- [이벤트 구조체](/docs/orbital/types/events) - EventData, EventCallback 등
- [에러 타입](/docs/orbital/types/errors) - 다양한 에러 타입과 처리

## 타입 안전성 팁

### Result 타입 활용

```rust
type ApiResult<T> = Result<T, Box<dyn std::error::Error>>;

fn safe_parse_user_id(id_str: &str) -> ApiResult<u64> {
    id_str.parse::<u64>()
        .map_err(|e| format!("Invalid user ID '{}': {}", id_str, e).into())
}
```

### Option 타입 활용

```rust
fn get_user_by_id(id: u64) -> Option<User> {
    if id > 0 && id < 1000 {
        Some(User {
            id,
            name: format!("User {}", id),
            email: format!("user{}@example.com", id),
            created_at: chrono::Utc::now(),
            is_active: true,
        })
    } else {
        None
    }
}
```

### 제네릭 타입 활용

```rust
pub struct ApiResponse<T> {
    pub success: bool,
    pub data: Option<T>,
    pub error: Option<String>,
    pub timestamp: chrono::DateTime<chrono::Utc>,
}

impl<T> ApiResponse<T> {
    pub fn success(data: T) -> Self {
        Self {
            success: true,
            data: Some(data),
            error: None,
            timestamp: chrono::Utc::now(),
        }
    }

    pub fn error(message: String) -> Self {
        Self {
            success: false,
            data: None,
            error: Some(message),
            timestamp: chrono::Utc::now(),
        }
    }
}
```

## 주요 트레이트

### Serialize/Deserialize

모든 주요 타입은 `serde`를 통한 직렬화를 지원합니다:

```rust
use serde::{Serialize, Deserialize};

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct User {
    pub id: u64,
    pub username: String,
    pub email: String,
    pub created_at: chrono::DateTime<chrono::Utc>,
    pub is_active: bool,
}
```

### Display/Debug

대부분의 타입은 디버깅과 로깅을 위한 트레이트를 구현합니다:

```rust
impl std::fmt::Display for ApplicationStatus {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.summary())
    }
}
```

## 관련 문서

- [Application](/docs/orbital/application) - 애플리케이션 관리
- [Router](/docs/orbital/router) - 라우팅 시스템
- [Event System](/docs/orbital/event) - 이벤트 처리
