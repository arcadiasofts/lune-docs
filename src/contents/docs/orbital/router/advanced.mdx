---
title: 'ê³ ê¸‰ ë¼ìš°íŒ…'
path: 'orbital/router/advanced'
product: 'Orbital'
category: 'Router'
lastUpdate: 2025-09-05
order: 24
---

## ê°œìš”

Orbital Routerì˜ ê³ ê¸‰ ê¸°ëŠ¥ë“¤ì„ í™œìš©í•˜ì—¬ ë³µì¡í•œ ë¼ìš°íŒ… ë¡œì§ê³¼ ì¡°ê±´ë¶€ ì²˜ë¦¬ë¥¼ êµ¬í˜„í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ë™ì  ë¼ìš°íŒ…, ì¡°ê±´ë¶€ ë¼ìš°íŒ…, ì„±ëŠ¥ ìµœì í™” ë“±ì„ ë‹¤ë£¹ë‹ˆë‹¤.

## ë™ì  ë¼ìš°íŒ…

### ë™ì  ë¼ìš°íŠ¸ ìƒì„±

```rust
use orbital::router::{Router, RouteResponse};
use std::sync::Arc;
use std::collections::HashMap;

fn create_dynamic_routes() -> Router {
    let mut router = Router::new("Dynamic Router");

    // ì„¤ì • ê¸°ë°˜ ë¼ìš°íŠ¸ ìƒì„±
    let api_versions = vec!["v1", "v2", "v3"];
    let resources = vec!["users", "posts", "comments"];

    for version in &api_versions {
        for resource in &resources {
            let route_path = format!("/api/{}/{}", version, resource);
            let version_clone = version.to_string();
            let resource_clone = resource.to_string();

            // READ ë¼ìš°íŠ¸
            router.read(&route_path, Arc::new(move |_ctx| {
                Ok(RouteResponse::json(serde_json::json!({
                    "version": version_clone,
                    "resource": resource_clone,
                    "action": "list",
                    "data": []
                })))
            }));

            // CREATE ë¼ìš°íŠ¸
            let create_path = route_path.clone();
            let version_clone2 = version.to_string();
            let resource_clone2 = resource.to_string();

            router.create(&create_path, Arc::new(move |ctx| {
                let body = ctx.body_json().unwrap_or_default();

                Ok(RouteResponse::created(serde_json::json!({
                    "version": version_clone2,
                    "resource": resource_clone2,
                    "action": "create",
                    "data": body
                })))
            }));
        }
    }

    router
}
```

### ì¡°ê±´ë¶€ ë¼ìš°íŠ¸ ë“±ë¡

```rust
use orbital::router::Router;

struct RouteConfig {
    feature_flags: HashMap<String, bool>,
}

impl RouteConfig {
    fn new() -> Self {
        let mut flags = HashMap::new();
        flags.insert("experimental_api".to_string(), std::env::var("ENABLE_EXPERIMENTAL").is_ok());
        flags.insert("admin_panel".to_string(), std::env::var("ENABLE_ADMIN").is_ok());
        flags.insert("analytics".to_string(), std::env::var("ENABLE_ANALYTICS").is_ok());

        Self { feature_flags: flags }
    }

    fn is_enabled(&self, feature: &str) -> bool {
        self.feature_flags.get(feature).unwrap_or(&false).clone()
    }
}

fn create_conditional_router() -> Router {
    let mut router = Router::new("Conditional Router");
    let config = RouteConfig::new();

    // ê¸°ë³¸ ë¼ìš°íŠ¸ë“¤
    router.read("/api/health", Arc::new(|_ctx| {
        Ok(RouteResponse::json(serde_json::json!({
            "status": "healthy"
        })))
    }));

    // ì‹¤í—˜ì  ê¸°ëŠ¥
    if config.is_enabled("experimental_api") {
        router.read("/api/experimental/features", Arc::new(|_ctx| {
            Ok(RouteResponse::json(serde_json::json!({
                "features": ["feature_a", "feature_b"],
                "warning": "This is an experimental API"
            })))
        }));
    }

    // ê´€ë¦¬ì íŒ¨ë„
    if config.is_enabled("admin_panel") {
        router.read("/admin/dashboard", Arc::new(|_ctx| {
            Ok(RouteResponse::json(serde_json::json!({
                "dashboard": "admin_data"
            })))
        }));
    }

    // ë¶„ì„ ê¸°ëŠ¥
    if config.is_enabled("analytics") {
        router.read("/api/analytics/stats", Arc::new(|_ctx| {
            Ok(RouteResponse::json(serde_json::json!({
                "stats": {"requests": 1000, "errors": 5}
            })))
        }));
    }

    router
}
```

## ë¼ìš°íŠ¸ ë§¤ì¹­ ìµœì í™”

### ë¼ìš°íŠ¸ ìš°ì„ ìˆœìœ„

```rust
use orbital::router::{Router, RouteResponse};

let mut router = Router::new("Priority Router");

// êµ¬ì²´ì ì¸ ë¼ìš°íŠ¸ë¥¼ ë¨¼ì € ë“±ë¡ (ë†’ì€ ìš°ì„ ìˆœìœ„)
router.read("/api/users/me", Arc::new(|_ctx| {
    Ok(RouteResponse::json(serde_json::json!({
        "user": "current_user_info"
    })))
}));

router.read("/api/users/admin", Arc::new(|_ctx| {
    Ok(RouteResponse::json(serde_json::json!({
        "user": "admin_info"
    })))
}));

// ì¼ë°˜ì ì¸ ë§¤ê°œë³€ìˆ˜ ë¼ìš°íŠ¸ë¥¼ ë‚˜ì¤‘ì— ë“±ë¡ (ë‚®ì€ ìš°ì„ ìˆœìœ„)
router.read("/api/users/:id", Arc::new(|ctx| {
    let user_id = ctx.param("id").unwrap_or("0".to_string());
    Ok(RouteResponse::json(serde_json::json!({
        "user": {
            "id": user_id,
            "name": format!("User {}", user_id)
        }
    })))
}));

// ì™€ì¼ë“œì¹´ë“œëŠ” ê°€ì¥ ë§ˆì§€ë§‰ì— ë“±ë¡ (ê°€ì¥ ë‚®ì€ ìš°ì„ ìˆœìœ„)
router.read("/api/*", Arc::new(|ctx| {
    let path = ctx.param("*").unwrap_or("".to_string());
    Ok(RouteResponse::json(serde_json::json!({
        "message": "Catch-all route",
        "path": path
    })))
}));
```

### ë¼ìš°íŠ¸ ê·¸ë£¹ ìµœì í™”

```rust
use orbital::router::Router;

struct RouterBuilder {
    base_router: Router,
}

impl RouterBuilder {
    fn new(name: &str) -> Self {
        Self {
            base_router: Router::new(name),
        }
    }

    fn add_crud_routes(mut self, resource: &str, base_path: &str) -> Self {
        let resource_path = format!("{}/{}", base_path, resource);
        let resource_id_path = format!("{}/:{}_id", resource_path, resource);

        // LIST
        let resource_clone = resource.to_string();
        self.base_router.read(&resource_path, Arc::new(move |_ctx| {
            Ok(RouteResponse::json(serde_json::json!({
                "resource": resource_clone,
                "action": "list",
                "data": []
            })))
        }));

        // CREATE
        let resource_clone = resource.to_string();
        self.base_router.create(&resource_path, Arc::new(move |ctx| {
            Ok(RouteResponse::created(serde_json::json!({
                "resource": resource_clone,
                "action": "create",
                "data": ctx.body_json().unwrap_or_default()
            })))
        }));

        // READ
        let resource_clone = resource.to_string();
        let param_name = format!("{}_id", resource);
        self.base_router.read(&resource_id_path, Arc::new(move |ctx| {
            let id = ctx.param(&param_name).unwrap_or("0".to_string());
            Ok(RouteResponse::json(serde_json::json!({
                "resource": resource_clone,
                "action": "read",
                "id": id
            })))
        }));

        // UPDATE
        let resource_clone = resource.to_string();
        let param_name = format!("{}_id", resource);
        self.base_router.update(&resource_id_path, Arc::new(move |ctx| {
            let id = ctx.param(&param_name).unwrap_or("0".to_string());
            Ok(RouteResponse::json(serde_json::json!({
                "resource": resource_clone,
                "action": "update",
                "id": id,
                "data": ctx.body_json().unwrap_or_default()
            })))
        }));

        // DELETE
        let resource_clone = resource.to_string();
        let param_name = format!("{}_id", resource);
        self.base_router.remove(&resource_id_path, Arc::new(move |ctx| {
            let id = ctx.param(&param_name).unwrap_or("0".to_string());
            Ok(RouteResponse::json(serde_json::json!({
                "resource": resource_clone,
                "action": "delete",
                "id": id
            })))
        }));

        self
    }

    fn build(self) -> Router {
        self.base_router
    }
}

// ì‚¬ìš©ë²•
let api_router = RouterBuilder::new("API Router")
    .add_crud_routes("users", "/api")
    .add_crud_routes("posts", "/api")
    .add_crud_routes("comments", "/api")
    .build();
```

## ì¡°ê±´ë¶€ ë¼ìš°íŒ…

### í—¤ë” ê¸°ë°˜ ë¼ìš°íŒ…

```rust
use orbital::router::{Router, RouteResponse, Middleware};

struct ContentTypeRouter;

#[async_trait::async_trait]
impl Middleware for ContentTypeRouter {
    async fn handle(
        &self,
        req: LUNE,
        next: Next,
    ) -> Result<RouteResponse, Box<dyn std::error::Error>> {
        let content_type = req.header().get_custom_field("Content-Type")
            .unwrap_or("application/json");

        match content_type {
            "application/json" => {
                // JSON ìš”ì²­ ì²˜ë¦¬
                next.run(req).await
            },
            "application/xml" => {
                // XML ìš”ì²­ ì²˜ë¦¬ (ì˜ˆì‹œ)
                Ok(RouteResponse::json(serde_json::json!({
                    "message": "XML processing not implemented",
                    "content_type": content_type
                })))
            },
            "text/plain" => {
                // í…ìŠ¤íŠ¸ ìš”ì²­ ì²˜ë¦¬
                Ok(RouteResponse::text("Plain text response"))
            },
            _ => {
                Ok(RouteResponse::error(415, "Unsupported Media Type"))
            }
        }
    }
}

let mut router = Router::new("Content Type Router");
router.use_middleware(ContentTypeRouter);
```

### ì‚¬ìš©ì ê¸°ë°˜ ë¼ìš°íŒ…

```rust
use orbital::router::{Router, RouteResponse, Middleware};

struct UserBasedRouter;

#[async_trait::async_trait]
impl Middleware for UserBasedRouter {
    async fn handle(
        &self,
        req: LUNE,
        next: Next,
    ) -> Result<RouteResponse, Box<dyn std::error::Error>> {
        let user_type = req.body_json()
            .and_then(|body| body.get("user_type"))
            .and_then(|v| v.as_str())
            .unwrap_or("guest");

        match user_type {
            "admin" => {
                // ê´€ë¦¬ììš© ë¼ìš°íŒ…
                let admin_response = RouteResponse::json(serde_json::json!({
                    "message": "Admin access granted",
                    "features": ["full_access", "user_management", "analytics"]
                }));
                Ok(admin_response)
            },
            "premium" => {
                // í”„ë¦¬ë¯¸ì—„ ì‚¬ìš©ììš© ë¼ìš°íŒ…
                let premium_response = RouteResponse::json(serde_json::json!({
                    "message": "Premium access granted",
                    "features": ["advanced_features", "priority_support"]
                }));
                Ok(premium_response)
            },
            "user" => {
                // ì¼ë°˜ ì‚¬ìš©ììš© ë¼ìš°íŒ…
                next.run(req).await
            },
            _ => {
                // ê²ŒìŠ¤íŠ¸ìš© ì œí•œëœ ì‘ë‹µ
                Ok(RouteResponse::json(serde_json::json!({
                    "message": "Limited access for guests",
                    "features": ["basic_features"]
                })))
            }
        }
    }
}
```

## ì„±ëŠ¥ ìµœì í™”

### ë¼ìš°íŠ¸ ìºì‹±

```rust
use orbital::router::{Router, RouteResponse, Middleware};
use std::sync::{Arc, Mutex};
use std::collections::HashMap;
use std::time::{SystemTime, UNIX_EPOCH, Duration};

struct RouteCache {
    cache: Arc<Mutex<HashMap<String, (RouteResponse, u64)>>>,
    ttl_seconds: u64,
}

impl RouteCache {
    fn new(ttl_seconds: u64) -> Self {
        Self {
            cache: Arc::new(Mutex::new(HashMap::new())),
            ttl_seconds,
        }
    }

    fn get(&self, key: &str) -> Option<RouteResponse> {
        let mut cache = self.cache.lock().unwrap();
        let now = SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_secs();

        if let Some((response, timestamp)) = cache.get(key) {
            if now - timestamp < self.ttl_seconds {
                return Some(response.clone());
            } else {
                cache.remove(key);
            }
        }

        None
    }

    fn set(&self, key: String, response: RouteResponse) {
        let mut cache = self.cache.lock().unwrap();
        let now = SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_secs();
        cache.insert(key, (response, now));
    }
}

struct CachingMiddleware {
    cache: RouteCache,
}

impl CachingMiddleware {
    fn new(ttl_seconds: u64) -> Self {
        Self {
            cache: RouteCache::new(ttl_seconds),
        }
    }
}

#[async_trait::async_trait]
impl Middleware for CachingMiddleware {
    async fn handle(
        &self,
        req: LUNE,
        next: Next,
    ) -> Result<RouteResponse, Box<dyn std::error::Error>> {
        // ìºì‹œ í‚¤ ìƒì„± (ê²½ë¡œ + ì¿¼ë¦¬ ë§¤ê°œë³€ìˆ˜)
        let cache_key = format!("{}:{}",
            req.header().message_type(),
            serde_json::to_string(&req.body()).unwrap_or_default()
        );

        // ìºì‹œì—ì„œ í™•ì¸
        if let Some(cached_response) = self.cache.get(&cache_key) {
            println!("ğŸ“¦ Cache hit for key: {}", cache_key);
            return Ok(cached_response);
        }

        // ìºì‹œ ë¯¸ìŠ¤ - ì‹¤ì œ ì²˜ë¦¬
        let response = next.run(req).await?;

        // ì„±ê³µì ì¸ ì‘ë‹µë§Œ ìºì‹œ
        if response.status() < 400 {
            self.cache.set(cache_key.clone(), response.clone());
            println!("ğŸ’¾ Cached response for key: {}", cache_key);
        }

        Ok(response)
    }
}

// ì‚¬ìš©ë²•
let mut router = Router::new("Cached Router");
router.use_middleware(CachingMiddleware::new(300)); // 5ë¶„ TTL
```

### ë¹„ë™ê¸° ë¼ìš°íŠ¸ ì²˜ë¦¬

```rust
use orbital::router::{Router, RouteResponse};
use tokio::time::{sleep, Duration};
use std::sync::Arc;

let mut async_router = Router::new("Async Router");

// ë¹„ë™ê¸° ë°ì´í„°ë² ì´ìŠ¤ ì¡°íšŒ ì‹œë®¬ë ˆì´ì…˜
async_router.read("/api/users/:id", Arc::new(|ctx| async move {
    let user_id = ctx.param("id").unwrap_or("0".to_string());

    // ë¹„ë™ê¸° ë°ì´í„°ë² ì´ìŠ¤ ì¡°íšŒ ì‹œë®¬ë ˆì´ì…˜
    tokio::spawn(async move {
        sleep(Duration::from_millis(100)).await;
        println!("Database query completed for user {}", user_id);
    }).await.unwrap();

    Ok(RouteResponse::json(serde_json::json!({
        "user": {
            "id": user_id,
            "name": format!("User {}", user_id),
            "loaded_at": chrono::Utc::now().to_rfc3339()
        }
    })))
}));

// ë³‘ë ¬ ì²˜ë¦¬
async_router.read("/api/dashboard", Arc::new(|_ctx| async move {
    // ì—¬ëŸ¬ ë°ì´í„° ì†ŒìŠ¤ì—ì„œ ë³‘ë ¬ë¡œ ë°ì´í„° ê°€ì ¸ì˜¤ê¸°
    let (users, posts, comments) = tokio::join!(
        fetch_users(),
        fetch_posts(),
        fetch_comments()
    );

    Ok(RouteResponse::json(serde_json::json!({
        "dashboard": {
            "users": users?,
            "posts": posts?,
            "comments": comments?,
            "generated_at": chrono::Utc::now().to_rfc3339()
        }
    })))
}));

async fn fetch_users() -> Result<serde_json::Value, Box<dyn std::error::Error>> {
    sleep(Duration::from_millis(50)).await;
    Ok(serde_json::json!({"count": 100}))
}

async fn fetch_posts() -> Result<serde_json::Value, Box<dyn std::error::Error>> {
    sleep(Duration::from_millis(75)).await;
    Ok(serde_json::json!({"count": 250}))
}

async fn fetch_comments() -> Result<serde_json::Value, Box<dyn std::error::Error>> {
    sleep(Duration::from_millis(30)).await;
    Ok(serde_json::json!({"count": 500}))
}
```

## ë¼ìš°íŠ¸ í…ŒìŠ¤íŒ…

### ë¼ìš°íŠ¸ ë‹¨ìœ„ í…ŒìŠ¤íŠ¸

```rust
#[cfg(test)]
mod tests {
    use super::*;
    use orbital::r#struct::LUNE;
    use orbital::router::{Router, RouteContext};

    #[tokio::test]
    async fn test_user_route() {
        let mut router = Router::new("Test Router");

        router.read("/users/:id", Arc::new(|ctx| {
            let user_id = ctx.param("id").unwrap_or("0".to_string());
            Ok(RouteResponse::json(serde_json::json!({
                "user_id": user_id
            })))
        }));

        // í…ŒìŠ¤íŠ¸ìš© LUNE ë©”ì‹œì§€ ìƒì„±
        let mut test_message = LUNE::new();
        test_message.set_type("READ /users/123".to_string());
        test_message.set_body(b"{}".to_vec());

        let response = router.handle_message(&test_message, "test_connection".to_string()).unwrap();

        assert!(response.is_handled());
        // ì¶”ê°€ ì‘ë‹µ ê²€ì¦...
    }

    #[tokio::test]
    async fn test_error_handling() {
        let mut router = Router::new("Error Test Router");

        router.read("/error", Arc::new(|_ctx| {
            Err("Test error".into())
        }));

        let mut test_message = LUNE::new();
        test_message.set_type("READ /error".to_string());
        test_message.set_body(b"{}".to_vec());

        let result = router.handle_message(&test_message, "test_connection".to_string());

        assert!(result.is_err());
    }
}
```

## ë‹¤ìŒ ë‹¨ê³„

ê³ ê¸‰ ë¼ìš°íŒ…ì— ëŒ€í•´ ì•Œì•„ë³´ì•˜ë‹¤ë©´, ë‹¤ìŒ ë¬¸ì„œë“¤ì„ í™•ì¸í•´ë³´ì„¸ìš”:

- [ì—ëŸ¬ ì²˜ë¦¬](/docs/orbital/router/error-handling) - ë¼ìš°íŠ¸ë³„ ì—ëŸ¬ ì²˜ë¦¬
- [ë¯¸ë“¤ì›¨ì–´](/docs/orbital/router/middleware) - ë¯¸ë“¤ì›¨ì–´ ì²´ì¸ê³¼ ì»¤ìŠ¤í…€ ë¯¸ë“¤ì›¨ì–´
- [Router ì‹œì‘í•˜ê¸°](/docs/orbital/router/getting-started) - ê¸°ë³¸ ë¼ìš°íŒ…
